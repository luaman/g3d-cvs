/**
 @file ShadowMappedLightPass.vrt
 @author Morgan McGuire, morgan@cs.williams.edu
 @created 2007-10-22
 @edited  2009-03-25 
 */
#ifdef CUSTOMCONSTANT
    uniform vec4        customConstant;
#endif

#ifdef NORMALBUMPMAP
    /** Vector to the eye in tangent space (needed for parallax) */
    varying vec3 _tsE;

    /** Tangent space to world space.
    Note that this will be linearly interpolated across the polygon.

    NVIDIA drivers do not properly interpolate mat4, so we must pass
    the columns along a separate vectors. */
    varying vec4 tan_X, tan_Y;
#endif

varying vec4 tan_Z;

/** Point on the surface being shaded */
varying vec3 wsPosition; 

/** Modelview projection matrix used for the light's shadow map */
uniform mat4 lightMVP;

/** Coordinate to use in the shadow map */
varying vec4 shadowCoord;

varying vec2 texCoord;

void main(void) {

    vec3 wsEyePos = g3d_CameraToWorldMatrix[3].xyz;

    wsPosition = (g3d_ObjectToWorldMatrix * gl_Vertex).xyz;

    tan_Z = g3d_ObjectToWorldMatrix * vec4(gl_Normal, 0);

#   ifdef NORMALBUMPMAP
        tan_X = g3d_ObjectToWorldMatrix * vec4(gl_MultiTexCoord1.xyz, 0);

        // T and N are guaranteed perpendicular, so B is normalized.
        tan_Y = vec4(cross(tan_Z.xyz, tan_X.xyz), 0);

	    // (there is no tan_W, because it is equal to wsPosition)

        // Compute the tangent space eye vector (ATI does not support the transpose operator)
        mat3 worldToTangent = mat3(tan_X.x, tan_Y.x, tan_Z.x,
                                    tan_X.y, tan_Y.y, tan_Z.y,
                                    tan_X.z, tan_Y.z, tan_Z.z);

        _tsE         = worldToTangent * (wsEyePos - wsPosition);
#    endif

    shadowCoord      = lightMVP * vec4(wsPosition, 1.0);

    texCoord         = (gl_TextureMatrix[0] * gl_MultiTexCoord0).st;
    gl_Position      = ftransform();
}
