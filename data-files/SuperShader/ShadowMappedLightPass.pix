/**
  @file ShadowMappedLightPass.glsl.frg
  @author Morgan McGuire matrix@graphics3d.com

  For use with G3D::SuperShader.
  @edited 2007-12-18
 */

/** World space */
uniform vec4        lightPosition;
uniform vec3        lightColor;
uniform vec3        lightAttenuation;

#ifdef CUSTOMCONSTANT
    uniform vec4        customConstant;
#endif

#ifdef CUSTOMMAP
    uniform sampler2D   customMap;
#endif

#ifdef SPECULARCONSTANT
    uniform vec3        specularConstant;
#endif

#ifdef SPECULARMAP
    uniform sampler2D   specularMap;
#endif

#ifdef SPECULAREXPONENTCONSTANT
    uniform vec3        specularExponentConstant;
#endif

#ifdef SPECULAREXPONENTMAP
    uniform sampler2D   specularExponentMap;
#endif

#if defined(DIFFUSECONSTANT)
    uniform vec3        diffuseConstant;
#endif

#ifdef DIFFUSEMAP
    uniform sampler2D   diffuseMap;
#endif

/** Set to -1 to flip the normal. */
uniform float       backside;

#ifdef G3D_ATI
   // On ATI cards, use regular 2D texturing since
   // depth textures provide no advantage.
   uniform sampler2D shadowMap;
#else
   uniform sampler2DShadow shadowMap;
#endif

// World parameters
varying vec3        wsEyePos;
varying vec2        texCoord;

#ifdef NORMALBUMPMAP
    /** Multiplier for bump map.  Typically on the range [0, 0.05]
      This increases with texture scale and bump height. */
    uniform float       bumpMapScale;

    /** How high is the 0-level of the bump map? On the range [0, 1] */
    uniform float       bumpMapBias;

    /** xyz = normal, w = bump height */
    uniform sampler2D   normalBumpMap;

    /** Un-normalized (interpolated) tangent space eye vector */
    varying vec3        _tsE;

    varying vec4        tan_X, tan_Y;
#endif

varying vec4        tan_Z, tan_W;

/** Coordinate to use in the shadow map */
varying vec4        shadowCoord;

/** Used for "ambient occlusion" */
varying float       accessibility;

#ifdef NORMALBUMPMAP
#   if (PARALLAXSTEPS == 0)

    /**
     Normal mapping
     Following the algorithm of Blinn '78
     */
    void applyBumpMap(out vec3 wsN, out vec2 offsetTexCoord) {
        
        offsetTexCoord = texCoord.xy;
    	    
        // Take the normal map values back to (-1, 1) range to compute a tangent space normal
        vec3 tsN = texture2D(normalBumpMap, offsetTexCoord).xyz * 2.0 + vec3(-1.0, -1.0, -1.0);

        // note that the columns might be slightly not orthogonal due to interpolation
        mat3 tangentToWorld = mat3(tan_X.xyz, tan_Y.xyz, tan_Z.xyz);

        // Take the normal to world space
        wsN = (tangentToWorld * tsN) * backside;
    }

#   elif (PARALLAXSTEPS <= 1)

    /**
     Parallax mapping
     Following the algorithm of Welsh '04
     */
    void applyBumpMap(out vec3 wsN, out vec2 offsetTexCoord) {
        // Convert bumps to a world space distance
        float bump = (texture2D(normalBumpMap, texCoord).w - 0.5) * bumpMapScale;

        vec3 tsE = normalize(_tsE);

        // Offset the texture coord.  Note that texture coordinates are inverted (in the y direction)
        // from TBN space, so we must flip the y-axis.

        offsetTexCoord = texCoord.xy + vec2(tsE.x, -tsE.y) * bump;
    	    
        // Take the normal map values back to (-1, 1) range to compute a tangent space normal
        vec3 tsN = texture2D(normalBumpMap, offsetTexCoord).xyz * 2.0 + vec3(-1.0, -1.0, -1.0);

        // note that the columns might be slightly not orthogonal due to interpolation
        mat3 tangentToWorld = mat3(tan_X.xyz, tan_Y.xyz, tan_Z.xyz);

        // Take the normal to world space
        wsN = (tangentToWorld * tsN) * backside;
    }


#   else

    /**
     Parallax Occlusion Mapping (POM)

     Following the algorithm of Tatarchuk I3D '06
     
     Linear search and linear interpolation after the hit.
     Constants have been adjusted to give high performance on GeForce cards.
     */
    void applyBumpMap(out vec3 wsN, out vec2 offsetTexCoord) {
        vec3 tsE = normalize(_tsE);

        // Actual texture coordinate that we'll use based on
        // parallax offset.  The z coordinate is the height of the
        // bump above the surface
        vec3 offsetCoord;

        // Packed tangent space normals (to be unpacked below)
        vec3 tsN;

        // Back up the intersection since we should be entering the surface
        // at the top of the bounding box (bump = 1) and the initial intersection point 
        // is with bump = 0.5
        //
        // Note that we negate tsE because tsE points towards the eye
        // and we're walking away from the eye; also note that we negate
        // the y coordinate because our texture coords are inverted in y.
        offsetCoord.xy = texCoord - bumpMapBias * bumpMapScale * vec2(-tsE.x, tsE.y) / tsE.z;

        // Normalized height of the eye ray above the surface (i.e., not multiplied 
        // by bumpScale to avoid the cost of bump height on the inner loop.)
        offsetCoord.z = 1.0;
        const float MIN_STEPS = 2.0;

        // Increase the number of steps taken as the eye vector begins 
        // to point more horizontally (ala Tatarchuk).  Expand the range of tsE.z; it rarely gets near zero on its own.

        float numSteps = mix(max(float(PARALLAXSTEPS) * bumpMapScale * 2, MIN_STEPS), MIN_STEPS,  max(0.0, (tsE.z - 0.4) / 0.6) );
        vec3 tsStep;

        // Distance that we'll step in z (normal direction) for each 
        // iteration; by definition we have to cover bumpScale distance
        // in numSteps.
        tsStep.z = -1.0 / numSteps; 

        // Corresponding (x, y) step, by similar triangles; note that
        // tsStep.z is negative so we've negated the eye vector again,
        // giving us back the positive version.
        tsStep.xy = (vec2(tsE.x, -tsE.y) / tsE.z) * (bumpMapScale * tsStep.z);

        // Surface normal and bump map values.
        vec4 NB = texture2D(normalBumpMap, offsetCoord.xy);

        // March forward until the view ray sinks below the current
        // surface elevation.  At each point, offsetCoord will be the
        // next location, and we'll overshoot slightly.
        while (NB.w < offsetCoord.z) {
            offsetCoord += tsStep;
            NB = texture2D(normalBumpMap, offsetCoord.xy);
        }

        // We've overshot slightly.  Assume that the surface is piecewise linear ala Policarop and Oliveira '06, Tatarchuk '06
        //
        // By similar triangles, the overshoot is thus governed by the ratios:
        // 
        //    last ray elevation - last surface elevation             surface dist from last to true intersection             P
        //  -----------------------------------------------      =   -------------------------------------------------   = -------
        //  current surface elevation - current ray elevation         surface dist from current to true intersection          Q
        //
        // In other words, we want to step back by (tsStep * Q / (P + Q)).  The denominator of that ratio
        // can never be zero or we would be travelling parallel to the surface and should have hit on the
        // previous iteration.  However, it can be very small--so small that it underflows.
        //
        // P = (offsetCoord.z - tsStep.z) - prevNB.w;
        // Q = NB.w - offsetCoord.z;
        //
        // alpha = 
        // Q / (P + Q) = (NB.w - offsetCoord.z) / ( (offsetCoord.z - tsStep.z) - prevNB.w + NB.w - offsetCoord.z)
        //             = (NB.w - offsetCoord.z) / (NB.w -tsStep.z - prevNB.w)
        
        // (We could have tracked prevNB in the inner while loop, but in testing on NVIDIA GeForce 7800, 
        // it was faster to just perform one very-coherent texture read at the end than add instructions to
        // the inner loop)
        vec4 prevNB = texture2D(normalBumpMap, offsetCoord.xy - tsStep.xy);

        float denom = NB.w - tsStep.z - prevNB.w;
        denom = max(abs(denom), 0.125) * sign(denom);
        float alpha = (NB.w - offsetCoord.z) / denom;
        offsetCoord -= tsStep * alpha;

        // Take the tangent back appropriately
        tsN = mix(NB.xyz, prevNB.xyz, alpha) * 2.0 + vec3(-1.0, -1.0, -1.0);

        offsetTexCoord = offsetCoord.xy;

        // Note that the columns might be slightly not orthogonal due to interpolation
        mat3 tangentToWorld = mat3(tan_X.xyz, tan_Y.xyz, tan_Z.xyz * backside);

        // Take the normal to world space
        wsN = (tangentToWorld * tsN); 
    }
#   endif // Parallax Steps > 1
#endif

void main(void) {
    vec3 wsEyePos = g3d_CameraToWorldMatrix[3].xyz;

#   ifdef NORMALBUMPMAP

        vec3 wsN;
        vec2 offsetTexCoord;
        applyBumpMap(wsN, offsetTexCoord);

#   else
        vec2 offsetTexCoord = texCoord;

        // World space normal
        vec3 wsN = tan_Z.xyz * backside;
#   endif

    // or... (tangentToWorld * vec4(tsE, 0.0)).xyz;

    // Light vector
    vec3 wsL = lightPosition.xyz - tan_W.xyz * lightPosition.w;
    float lightDistance = length(wsL);
    wsL = wsL / lightDistance;

    vec3 attLightColor = lightColor / dot( vec3(1.0, lightDistance, lightDistance * lightDistance), 
                                          lightAttenuation)
#   ifdef NORMALBUMPMAP
        // For a bump mapped surface, do not allow illumination on the back side even if the
        // displacement creates a light-facing surface, since it should be self-shadowed for any 
        // large polygon.
        * float(dot(tan_Z.xyz, wsL) * backside > 0.0);
#   endif
                                          ;

#   if defined(SPECULARCONSTANT) || defined(SPECULARMAP)
        // Eye vector
        vec3 wsE = wsEyePos - tan_W.xyz;

        // Reflection vector
        vec3 wsR = normalize((wsN * 2.0 * dot(wsN, wsE)) - wsE);
#   endif

#   if (defined(DIFFUSECONSTANT) || defined(DIFFUSEMAP))
        vec4 diffuseColor =
#       ifdef DIFFUSECONSTANT
            vec4(diffuseConstant, 1.0)
#           ifdef DIFFUSEMAP
                * texture2D(diffuseMap, offsetTexCoord)
#           endif
#       else
            texture2D(diffuseMap, offsetTexCoord)
#       endif
        ;
#   endif


#   if defined(SPECULARCONSTANT) || defined(SPECULARMAP)
        vec4 specularColor =
#       ifdef SPECULARCONSTANT
            vec4(specularConstant, 1.0)
#           ifdef SPECULARMAP
                * texture2D(specularMap, offsetTexCoord)
#          endif
#       else
            texture2D(specularMap, offsetTexCoord)
#       endif
        ;
#   endif


#   if defined(SPECULAREXPONENTCONSTANT) || defined(SPECULAREXPONENTMAP)     
        vec4 specularExponentColor =
#       ifdef SPECULAREXPONENTCONSTANT
            vec4(specularExponentConstant, 1.0)
#           ifdef SPECULAREXPONENTMAP
                * texture2D(specularExponentMap, offsetTexCoord)
#           endif
#       else
            texture2D(specularExponentMap, offsetTexCoord)
#       endif
        ;
#   else
        vec4 specularExponentColor = vec4(1.0, 1.0, 1.0, 1.0);
#   endif

    // Compute projected shadow coord.
    vec4 projShadowCoord = shadowCoord / shadowCoord.w;

    // "side" and "diagonal" offset variables used to produce vectors to the 
    // 8-neighbors, which leads to a smoother shadow result (0.71 is sqrt(2)/2).
    vec4 s = vec4(g3d_sampler2DInvSize(shadowMap), -g3d_sampler2DInvSize(shadowMap).x, 0.0);
    vec4 d = s * 0.71;

#   ifdef G3D_ATI
        // On ATI, percentage closer filtering is not available.  Perform nearest neighbor
        // sampling with explicit depth comparisons.  We use dot products to perform four compares
        // at once and sum their results; this saves four instructions.  We could also (but do not
        // in this implementation) perform our own bilinear to smooth as well as blur the results.

       vec3 shadow = 
vec3(

float(texture2D(shadowMap, projShadowCoord.xy).r > projShadowCoord.z) +

dot(vec4(1,1,1,1),
vec4(greaterThan(vec4(
     texture2D(shadowMap, projShadowCoord.xy + s.xw).r,
     texture2D(shadowMap, projShadowCoord.xy - s.xw).r,
     texture2D(shadowMap, projShadowCoord.xy + s.wy).r,
     texture2D(shadowMap, projShadowCoord.xy - s.wy).r), projShadowCoord.zzzz))) +

dot(vec4(1,1,1,1),
vec4(greaterThan(vec4(
     texture2D(shadowMap, projShadowCoord.xy + s.xy).r,
     texture2D(shadowMap, projShadowCoord.xy - s.xy).r,
     texture2D(shadowMap, projShadowCoord.xy + s.zy).r,
     texture2D(shadowMap, projShadowCoord.xy - s.zy).r), projShadowCoord.zzzz))) 
) / 9.0;
       
#   else
       vec3 shadow = 
            (shadow2D(shadowMap, projShadowCoord.xyz).rgb +
         
            shadow2D(shadowMap, projShadowCoord.xyz + s.xww).rgb +
            shadow2D(shadowMap, projShadowCoord.xyz - s.xww).rgb +
            shadow2D(shadowMap, projShadowCoord.xyz + s.wyw).rgb +
            shadow2D(shadowMap, projShadowCoord.xyz - s.wyw).rgb +

            shadow2D(shadowMap, projShadowCoord.xyz + d.xyw).rgb +
            shadow2D(shadowMap, projShadowCoord.xyz - d.zyw).rgb +
            shadow2D(shadowMap, projShadowCoord.xyz + d.zyw).rgb +
            shadow2D(shadowMap, projShadowCoord.xyz - d.xyw).rgb) / 9.0;
#   endif

    gl_FragColor.rgb = 
            accessibility * attLightColor * shadow *
        ( 
        vec3(0.0, 0.0, 0.0)
#       if defined(DIFFUSECONSTANT) || defined(DIFFUSEMAP)
            // Diffuse
            + max(dot(wsL, wsN), 0.0) * diffuseColor.rgb
#       endif

#       if defined(SPECULARCONSTANT) || defined(SPECULARMAP)
            + pow(vec3(max(dot(wsL, wsR), 0.0)), specularExponentColor.rgb) * specularColor.rgb
#       endif
            );

    gl_FragColor.a = 1.0

#       if defined(DIFFUSECONSTANT) || defined(DIFFUSEMAP)
           * diffuseColor.a
#       endif

#       if defined(SPECULARCONSTANT) || defined(SPECULARMAP)
            * specularColor.a
#       endif

#       if defined(SPECULAREXPONENTRCONSTANT) || defined(SPECULAREXPONENTMAP)
            * specularExponentColor.a
#       endif
        ;
}
