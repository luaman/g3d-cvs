/**
  @file NonShadowedPass.pix
  @author Morgan McGuire morgan@cs.williams.edu

  For use with G3D::SuperShader.

  @modified 2007-10-26
 */

/** World space light position */
uniform vec4        lightPosition[4];
uniform vec3        lightColor[4];
uniform vec3        lightAttenuation[4];

uniform vec3        environmentConstant;
uniform samplerCube environmentMap;

#ifdef CUSTOMCONSTANT
    uniform vec4        customConstant;
#endif

#ifdef CUSTOMMAP
    uniform sampler2D   customMap;
#endif

// Material
#ifdef REFLECTCONSTANT
    uniform vec3        reflectConstant;
#endif

#ifdef REFLECTMAP
    uniform sampler2D   reflectMap;
#endif

#ifdef SPECULARCONSTANT
    uniform vec3        specularConstant;
#endif

#ifdef SPECULARMAP
    uniform sampler2D   specularMap;
#endif

#ifdef SPECULAREXPONENTCONSTANT
    uniform vec3        specularExponentConstant;
#endif

#ifdef SPECULAREXPONENTMAP
    uniform sampler2D   specularExponentMap;
#endif

#ifdef EMITCONSTANT
    uniform vec3        emitConstant;
#endif

#ifdef EMITMAP
    uniform sampler2D   emitMap;
#endif

#ifdef DIFFUSECONSTANT
    uniform vec3        diffuseConstant;
#endif

#ifdef DIFFUSEMAP
    uniform sampler2D   diffuseMap;
#endif

#ifdef NORMALBUMPMAP
    /** Multiplier for bump map.  Typically on the range [0, 0.05]
      This increases with texture scale and bump height. */
    uniform float       bumpMapScale;

    /** How high is the 0-level of the bump map? On the range [0, 1] */
    uniform float       bumpMapBias;

    /** xyz = normal, w = bump height */
    uniform sampler2D   normalBumpMap;

    /** Un-normalized (interpolated) tangent space eye vector */
    varying vec3        _tsE;
    varying vec4        tan_X, tan_Y, tan_W;
#endif

varying vec4        tan_Z;
uniform vec3        ambientTop;
uniform vec3        ambientBottom;

// World parameters
varying vec3        wsPosition;
varying vec2        texCoord;

/** Set to -1 to flip the normal. */
uniform float       backside;

/** Used for "ambient occlusion" */
varying float       accessibility;

void addLightContribution(in vec3 wsN, in vec3 wsR, in vec3 wsPosition, in vec4 specularExponentColor, 
                          in vec4 lightPosition, in vec3 lightAttenuation, 
                          in vec3 lightColor, inout vec3 I_diffuse, inout vec3 I_specular) {
    
    // Light vector
    vec3 wsL = lightPosition.xyz - wsPosition.xyz * lightPosition.w;
    float lightDistance = length(wsL);
    wsL = wsL / lightDistance;
    vec3 attLightColor = lightColor / dot( vec3(1.0, lightDistance, lightDistance * lightDistance), lightAttenuation);

#   ifdef NORMALBUMPMAP
        // For a bump mapped surface, do not allow illumination on the back side even if the
        // displacement creates a light-facing surface, since it should be self-shadowed for any 
        // large polygon.
        attLightColor = attLightColor * float(dot(tan_Z.xyz, wsL) * backside > 0.0);
#   endif

#   if defined(DIFFUSECONSTANT) || defined(DIFFUSEMAP)
        I_diffuse = I_diffuse + max(dot(wsL, wsN), 0.0) * attLightColor;
#   endif

#   if defined(SPECULARCONSTANT) || defined(SPECULARMAP)
        I_specular = I_specular + pow(vec3(max(dot(wsL, wsR), 0.0)), specularExponentColor.rgb) * attLightColor;
#   endif
}

void main(void) {

    const vec3 BLACK = vec3(0.0, 0.0, 0.0);

    vec3 wsEyePos = g3d_CameraToWorldMatrix[3].xyz;

#   ifdef NORMALBUMPMAP
        // Convert bumps to a world space distance
        float  bump   = (texture2D(normalBumpMap, texCoord).w - 0.5) * bumpMapScale;

        vec3 tsE = normalize(_tsE);

        // Offset the texture coord.  Note that texture coordinates are inverted (in the y direction)
        // from TBN space, so we must flip the y-axis.

        vec2 offsetTexCoord = texCoord.xy + vec2(tsE.x, -tsE.y) * bump;
    	    
        // Take the normal map values back to (-1, 1) range to compute a tangent space normal
        vec3 tsN = (texture2D(normalBumpMap, offsetTexCoord).xyz - vec3(0.5, 0.5, 0.5)) * 2.0;

        // note that the columns might be slightly not orthogonal due to interpolation
        mat3 tangentToWorld = mat3(tan_X.xyz, tan_Y.xyz, tan_Z.xyz * backside);

        // Take the normal to world space
        vec3 wsN = tangentToWorld * tsN;

#   else

        // World space normal
        vec3 wsN = tan_Z.xyz * backside;

        vec2 offsetTexCoord = texCoord;
#   endif


#   if defined(REFLECTCONSTANT) || defined(REFLECTMAP) || defined(SPECULARCONSTANT) || defined(SPECULARMAP)
        // Eye vector
        vec3 wsE = wsEyePos - wsPosition;
        // or... (tangentToWorld * vec4(tsE, 0.0)).xyz;

        // Reflection vector
        vec3 wsR = normalize((wsN * 2.0 * dot(wsN, wsE)) - wsE);
#   else
        const vec3 wsR = BLACK;
#   endif

#   if (defined(DIFFUSECONSTANT) || defined(DIFFUSEMAP))
        vec4 diffuseColor =
#       ifdef DIFFUSECONSTANT
            vec4(diffuseConstant, 1.0)
#           ifdef DIFFUSEMAP
                * texture2D(diffuseMap, offsetTexCoord)
#           endif
#       else
            texture2D(diffuseMap, offsetTexCoord)
#       endif
        ;
#   endif


#   if defined(EMITCONSTANT) || defined(EMITMAP)     
        vec4 emitColor =
#       ifdef EMITCONSTANT
            vec4(emitConstant, 1.0)
#           ifdef EMITMAP
                * texture2D(emitMap, offsetTexCoord)
#          endif
#       else
            texture2D(emitMap, offsetTexCoord)
#       endif
        ;
#   endif


#   if defined(SPECULARCONSTANT) || defined(SPECULARMAP)     
        vec4 specularColor =
#       ifdef SPECULARCONSTANT
            vec4(specularConstant, 1.0)
#           ifdef SPECULARMAP
                * texture2D(specularMap, offsetTexCoord)
#          endif
#       else
            texture2D(specularMap, offsetTexCoord)
#       endif
        ;
#   endif


#   if defined(SPECULAREXPONENTCONSTANT) || defined(SPECULAREXPONENTMAP)     
        vec4 specularExponentColor =
#       ifdef SPECULAREXPONENTCONSTANT
            vec4(specularExponentConstant, 1.0)
#           ifdef SPECULAREXPONENTMAP
                * texture2D(specularExponentMap, offsetTexCoord)
#           endif
#       else
            texture2D(specularExponentMap, offsetTexCoord)
#       endif
        ;
#   else
        vec4 specularExponentColor = vec4(1.0, 1.0, 1.0, 1.0);
#   endif


#   if defined(REFLECTCONSTANT) || defined(REFLECTMAP)     
        vec4 reflectColor =
#       ifdef REFLECTCONSTANT
            vec4(reflectConstant, 1)
#           ifdef REFLECTMAP
                 * texture2D(reflectMap, offsetTexCoord)
#           endif
#       else
            texture2D(reflectMap, offsetTexCoord)
#       endif
        ;
#   endif


    vec3 I_diffuse  = ambientTop + (ambientTop - ambientBottom) * min(wsN.y, 0.0);
    vec3 I_specular = BLACK;

    for (int i = 0; i < 4; ++i) {
        addLightContribution(wsN, wsR, wsPosition, specularExponentColor, 
                             lightPosition[i], lightAttenuation[i], lightColor[i], I_diffuse, I_specular);
    }

    gl_FragColor.rgb =
        BLACK
#       if defined(EMITCONSTANT) || defined(EMITMAP)
            + emitColor.rgb
#       endif
        + accessibility * (

        BLACK

#       if defined(DIFFUSECONSTANT) || defined(DIFFUSEMAP)
           + I_diffuse * diffuseColor.rgb 
#       endif

#       if defined(SPECULARCONSTANT) || defined(SPECULARMAP)
            + I_specular * specularColor.rgb
#       endif

#       if defined(REFLECTCONSTANT) || defined(REFLECTMAP)     
            + textureCube(environmentMap, wsR).rgb * environmentConstant.rgb
            * reflectColor.rgb
#       endif
        );

    gl_FragColor.a = 1.0
#       if defined(EMITCONSTANT) || defined(EMITMAP)
            * emitColor.a
#       endif

#       if defined(DIFFUSECONSTANT) || defined(DIFFUSEMAP)
           * diffuseColor.a
#       endif

#       if defined(SPECULARCONSTANT) || defined(SPECULARMAP)
            * specularColor.a
#       endif

#       if defined(SPECULAREXPONENTRCONSTANT) || defined(SPECULAREXPONENTMAP)
            * specularExponentColor.a
#       endif

#       if defined(REFLECTCONSTANT) || defined(REFLECTMAP)     
            * reflectColor.a
#       endif
        ;

}
