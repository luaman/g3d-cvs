#!/usr/bin/env python
# -*- python -*-
#
# Build system for G3D.  Run 'buildg3d help' for options.
#

import os, platform, commands, sys, time, getopt, errno
import urllib, tarfile

# To get access to icompile routines
sys.path.append('bin')
import ice.copyifnewer, ice.utils
from ice.utils import run, pathConcat, shell, mkdir, VC9, _findBinary

doxygen = 'doxygen'
icompileConfig = []
distribDir = None

# G3D version.  Update this when the library version changes.
class Version:
    major = '7'
    minor = '01'
    beta  = '01'
    
    def toString(self):
        if (self.beta != ''):
            return self.major + '.' + self.minor + '-b' + self.beta
        else:
            return self.major + '.' + self.minor

g3dVersion = Version()
windows = None
freebsd = None
linux   = None
osx     = None
unix    = None
platformName = None

# e.g., win, osx
osShortName  = None

doInstall     = None
libInstallDir = None
docInstallDir = None

# Location of binary (subdir of build)
# Set by ??? TODO
buildDir = None

def initOS():
    global windows, freebsd, linux, osx, unix, osShortName
    global libInstallDir, docInstallDir, configFile, platformName
    global doInstall, icompileConfig

    s = platform.system()
    windows = (s == 'Windows') or (s == 'Microsoft')
    freebsd = (s == 'FreeBSD')
    linux   = (s == 'Linux')
    osx     = (s == 'Darwin')
    unix    = freebsd or linux or osx

    osTable = \
            {'Microsoft': 'win', # Vista
             'Windows'  : 'win', # XP/NT
             'Linux'    : 'linux',
             'Darwin'   : 'osx',
             'FreeBSD'  : 'freebsd'}
    
    osShortName = osTable[platform.system()]

    if unix:
        # Extract and remove config file from argument list
        try:
            i = sys.argv.index('--config')

            icompileConfig = sys.argv[i:i + 2]
            del sys.argv[i:i + 2]
        except ValueError:
            filename = pathConcat(os.environ['HOME'], '.icompile-buildg3d')
            if os.path.exists(filename):
                icompileConfig = ['--config', filename]
            else:
                icompileConfig = []

        print 'iCompile options: ', icompileConfig

    if windows:
        platformName = 'win-i386-vc9.0'
        installDir = 'c:/libraries'
    else:
        installDir = '/usr/local'

        os.chdir('G3D.lib')
        info = shell('../bin/icompile ' + ' '.join(icompileConfig + ['--info']), False)
        try:
            i = info.index('\nplatform')
            i = info.index('"', i) + 1
            j = info.index('"', i)
            platformName = info[i:j]
        except ValueError:
            # Could not find the information!
            raise Exception('icompile --info returned unparsable data')

        os.chdir('..')

    # Extract and remove config file from argument list
    try:
        i = sys.argv.index('--install')
        del sys.argv[i]

        doInstall = True
        # See if there is a directory
        if len(sys.argv) > i:
            pathname = sys.argv[i]
            if os.path.exists(pathname) and pathname != 'lib' and pathname != 'tools':
                installDir = pathname
                del sys.argv[i]
            
    except ValueError:
        doInstall = False

    if windows:
        libInstallDir = pathConcat(installDir, 'G3D-' + g3dVersion.toString())
        docInstallDir = libInstallDir
    else:
        libInstallDir = installDir
        docInstallDir = pathConcat(installDir, 'G3D-' + g3dVersion.toString())

initOS()

def copyIfNewer(source, dest):
    if windows:
        # Use the binary
        print 'copyifnewer', source, dest
        return os.spawnv(os.P_WAIT, 'bin\\copyifnewer.exe', 
                   ['bin\\copyifnewer.exe', '--super-exclusions', source, dest])
    else:
        # Use python commands
        ice.copyifnewer.copyIfNewer(source, dest)
        return 0


""" Runs iCompile in both debug and release mode (if debug succeeds) and returns
    the error code from the last run. 
"""
def runicompile(dir):
     os.chdir(dir)
     x = run('../bin/icompile', icompileConfig + ['--noprompt'], True)

     if (x == 0): 
         x = run('../bin/icompile', icompileConfig + ['-O', '--noprompt'], True)

     os.chdir('..')

     return x

##################################################################################

# Called frum libTarget on unix-platforms to build the ffmpeg libraries, which do not use icompile
def buildNativeFFMPEG():
    if windows: raise Error('Cannot build FFMPEG directly on Windows.  Must use cross-compiler')

    make = 'make'
    if freebsd:
        # freebsd ships with an ancient make version
        make = 'gmake'

    libs = ['libavutil.a', 'libavcodec.a', 'libavformat.a']
    print '----------------------------------------------------\n'
    print 'Building ' + ', '.join(libs)

    buildLibPath = pathConcat('build', platformName, 'lib')

    # Check to see if any ffmpeg library needs to be built
    outOfDate = [(not os.path.exists(pathConcat(buildLibPath, lib))) for lib in libs]
    needRebuild = reduce(lambda x,y: x or y, outOfDate, False)

    if not needRebuild:
        return 0

    sourceDir = os.path.abspath('temp/ffmpeg/native')
    installDir = os.path.abspath('temp/ffmpeg/native/install')

    # remove old build
    ice.utils.rmdir(os.path.abspath('temp/ffmpeg/native'), False)

    # extract ffmpeg sources
    ice.utils.mkdir(sourceDir, False)
    tarname = 'ffmpeg/source/ffmpeg_source.tar.bz2'
    tarObject = tarfile.open(tarname)
    ffmpegName = tarObject.next().name
    print '\nExtracting tarfile'
    #tarObject.extractall(sourceDir)  <--- only available on python 2.5
    os.chdir(sourceDir)
    retVal = ice.utils.run('tar', ['--bzip2', '-xvf', pathConcat('../../..', tarname)])
    os.chdir('../../..')
    tarObject.close()
    tarObject = None

    if retVal != 0:
        print 'Tar command failed'
        return retVal


    # build ffmpeg 
    oldcwd = os.getcwd()
    os.chdir(pathConcat(sourceDir, ffmpegName))
    ffmpegBuildScript = """
    echo Running configure in """ + pathConcat(sourceDir, ffmpegName) + """
    configure --enable-static --prefix=""" + installDir + """ --disable-network --disable-ipv6 --disable-bzlib --disable-ffplay --disable-ffserver --disable-ffmpeg --disable-debug
    echo Running make...
    """ + make + """
    echo Make install...
    """ + make + """ install
    """
    print 'Compiling...'
    retVal = ice.utils.run('sh', ['-c', ffmpegBuildScript], False)
    os.chdir(oldcwd)

    if retVal == 0:
        # copy the static libraries to the build directory
        for lib in libs:
            ice.copyifnewer.copyIfNewer(pathConcat(installDir, 'lib', lib),
                                        pathConcat(buildLibPath, lib))

    print '----------------------------------------------------'
    return retVal


#################################################################################

def libTarget():
     x = 0

     if windows:
         x = VC9('VC9/G3D.sln', ['jpeg.lib', 'png.lib', 'zlib.lib', 'zip.lib', 'G3D.lib', 'GLG3D.lib']);
             
     else:
    
         if osx:
             # Build jpeg
             if x == 0: x = runicompile('jpeg.lib')

         if osx and not os.path.exists('/usr/X11/include/png.h'):
             # Build png
             if x == 0: x = runicompile('png.lib')

         if x == 0: x = runicompile('zip.lib')
         
         if x == 0: x = buildNativeFFMPEG()

         if x == 0: x = runicompile('G3D.lib')

         if x == 0: x = runicompile('GLG3D.lib')

         
     return x

##################################################################################
 
def toolsTarget():
    if windows:
        x = VC9('VC9/G3D.sln', ['gfxmeter', 'viewer']);

    else:
        x = libTarget()
     
        if (x == 0):
            os.chdir("tools/gfxmeter")
            x = run("../../bin/icompile", icompileConfig + ['--noprompt', '--opt'])
            os.chdir("../..")
            if x == 0:
                copyIfNewer(pathConcat('temp/tools/gfxmeter', platformName),
                            pathConcat(pathConcat('build/', platformName), 'bin/gfxmeter'))
            
        if (x == 0):
            os.chdir("tools/viewer")
            x = run("../../bin/icompile", icompileConfig + ['--noprompt', '--opt'])
            os.chdir("../..")
            if x == 0:
                copyIfNewer(pathConcat('temp/tools/viewer', platformName),
                            pathConcat(pathConcat('build/', platformName), 'bin/viewer'))

    if (x == 0):
        dest = pathConcat('build', pathConcat(platformName, 'bin'))
        copyIfNewer('bin', dest)
        os.remove(pathConcat(dest, 'PKZIP25.EXE'))

    return x

##################################################################################

def cleanTarget():
    ice.utils.rmdir('build')
    ice.utils.rmdir('temp')

    if windows:       
       return 0

    os.chdir("test")
    run("../bin/icompile", icompileConfig + ['--clean'])
    os.chdir("..")

    print 'gfxmeter'
    os.chdir("tools/gfxmeter")
    run("../../bin/icompile", icompileConfig + ['--clean'])
    os.chdir("../..")

    print 'viewer'
    os.chdir("tools/viewer")
    run("../../bin/icompile", icompileConfig + ['--clean'])
    os.chdir("../..")

    return 0

##################################################################################
    
def testTarget():
    
    if windows:
       x = VC9('VC9/G3D.sln', ['test']);
       if x == 0:
          x = run('temp/test/build/testd.exe')
          if x == 0:
              run('temp/test/build/test.exe')             
    else:
        x = libTarget()
        if x != 0:
            return x

        os.chdir("test")
        x = run('../bin/icompile', icompileConfig + ['--noprompt', '--run']) 
        if (x == 0):
            x = run('../bin/icompile', icompileConfig + ['--noprompt', '-O', '--run'])
        os.chdir('..')

    return x

##################################################################################
    
def docTarget():
    version = 'version ' + g3dVersion.major + '.' + g3dVersion.minor
    if (g3dVersion.beta != ''):
        version += ' beta ' + g3dVersion.beta

    version += ' - ' + time.strftime('%B %Y')

    copyIfNewer('doc-files/data-files', 'build/html')

    env = {'HEADER_FILE':    'doc-files/data-files/header.html',
           'FOOTER_FILE':    'doc-files/data-files/footer.html',
           'PROJECT_NUMBER': version}

    # Generate C++ docs
    run(doxygen, ['Doxyfile'], True, env)

    # Generate Java docs
    run(doxygen, ['Doxyfile-java'], True, env)

    # Generate demos and support
    copyIfNewer('data-files', 'build/data')
    copyIfNewer('demos', 'build/demos')

    return 0

##################################################################################

def allTarget():
    x = cleanTarget()
    if x == 0: x = libTarget()
    if x == 0:
        # Pretend that jar always succeeds;
        # it might fail for people who don't
        # have java
        jarTarget()
    
    if x == 0: x = testTarget()
    if x == 0: x = toolsTarget()
    if x == 0: x = docTarget()
    
    return x

##################################################################################

def updateTarget():
    x = libTarget()
    if x == 0:
        # Pretend that jar always succeeds;
        # it might fail for people who don't
        # have java
        jarTarget()
    
    if x == 0: x = toolsTarget()
    if x == 0: x = docTarget()
    
    return x

##################################################################################

"""
 Recursively zips the source into zipfile
"""
def zip(source, zipfile):
    print 'Creating ' + zipfile

    if windows:
        run('PKZIP25', ['-add', '-rec', '-lev=9', '-path=relative', zipfile, source])
    else:
        run('zip', ['-r', '-9', zipfile, source])

def srcTarget():
   # First copy everything to the temp directory to remove
   # CVS files
   ver = 'G3D-' + g3dVersion.toString()
   dest ='temp/' + ver + '/src/'
   mkdir(dest)
   copyIfNewer('.', dest)

   os.chdir('temp')
   # Now produce the zipfile
   zip(ver, '../build/' + ver + '-src.zip')
   os.chdir('..')

##################################################################################
    
def jarTarget():
   print 'Testing for javac and jar...'
   if windows:
       try:
           javac = _findBinary('javac')
           _findBinary('jar')
       except Exception:
           print 'javac or jar not found on this machine, skipping .jar creation!'
           return -1
   else:
       x = shell('javac', False)
       y = shell('jar', False)
       if len(x) < 200 or len(y) < 200:
           print 'javac or jar not found on this machine, skipping .jar creation!'
           return -1
       javac = 'javac'

   print 'Building G3D.jar...'
   mkdir('temp/G3D.jar/G3D')
   mkdir('build')
   
   shell(javac + ' -d temp/G3D.jar G3D.jar/G3D/*.java')

   ret = run('jar', ['-cf', 'build/G3D.jar', '-C', 'temp/G3D.jar', 'G3D'])

   if ret == 0:
       print 'Built build/G3D.jar'

   return ret

################################################################################
def ffmpegcTarget():
    # This builds the mingw cross-compiler
    downloadDir = os.path.abspath('temp/mingw')
    sourceDir = downloadDir + '/src'
    installDir = downloadDir + '/cc'

    oldcwd = os.getcwd()
    
    # clean out cross compiler
    ice.utils.rmdir(downloadDir, False)
    
    # make destination directory
    ice.utils.mkdir(installDir, False)
    
    # download binutils
    if (not os.path.exists(downloadDir + '/binutils-2.18.50-20080109-2-src.tar.gz')):
        print "Downloading binutils...\n"
        urllib.urlretrieve('http://heanet.dl.sourceforge.net/sourceforge/mingw/binutils-2.18.50-20080109-2-src.tar.gz', downloadDir + '/binutils-2.18.50-20080109-2-src.tar.gz')
    
    # download mingw components
    if (not os.path.exists(downloadDir + '/mingw-runtime-3.14.tar.gz') or not os.path.exists(downloadDir + '/w32api-3.11.tar.gz')):
        print "Downloading mingw + w32api...\n"
        urllib.urlretrieve('http://heanet.dl.sourceforge.net/sourceforge/mingw/mingw-runtime-3.14.tar.gz', downloadDir + '/mingw-runtime-3.14.tar.gz')
        urllib.urlretrieve('http://heanet.dl.sourceforge.net/sourceforge/mingw/w32api-3.11.tar.gz', downloadDir + '/w32api-3.11.tar.gz')

    # download gcc core
    if (not os.path.exists(downloadDir + '/gcc-core-4.3.1.tar.bz2')):
        print "Downloading gcc core\n"
        urllib.urlretrieve('ftp://ftp.ibiblio.org/pub/mirrors/gnu/ftp/gnu/gcc/gcc-4.3.1/gcc-core-4.3.1.tar.bz2', downloadDir + '/gcc-core-4.3.1.tar.bz2')

    # extract mingw components
    print "Extracting mingw + w32api...\n"
    tarObject = tarfile.open(downloadDir + '/mingw-runtime-3.14.tar.gz', 'r')
    tarObject.extractall(installDir + '/mingw32')
    tarObject.close()
    
    tarObject = tarfile.open(downloadDir + '/w32api-3.11.tar.gz', 'r')
    tarObject.extractall(installDir + '/mingw32')
    tarObject.close()

    # extract binutils
    print "Extracting binutils...\n"
    tarObject = tarfile.open(downloadDir + '/binutils-2.18.50-20080109-2-src.tar.gz', 'r')
    binutilsName = tarObject.next().name
    tarObject.extractall(sourceDir)
    tarObject.close()
    
    # configure binutils
    print "Building binutils...\n"
    ice.utils.mkdir(sourceDir + '/binutils_obj', False)
    os.chdir(sourceDir + '/binutils_obj')
    ice.utils.shell(sourceDir + '/' + binutilsName + '/configure --prefix="' + installDir + '" --target=mingw32 --disable-nls --with-gcc --with-gnu-as --with-gnu-ld --disable-shared', False)
    
    # build binutils
    ice.utils.shell('make CFLAGS="-O2 -fno-exceptions" LDFLAGS="-s"', False)
    ice.utils.shell('make install', False)
    os.chdir(oldcwd)
    
    # extract gcc core
    print "Extracting gcc core...\n"
    tarObject = tarfile.open(downloadDir + '/gcc-core-4.3.1.tar.bz2', 'r')
    gccName = tarObject.next().name
    tarObject.extractall(sourceDir)
    tarObject.close()

    # configure gcc core
    print "Building gcc core...\n"
    ice.utils.mkdir(sourceDir + '/gcc_obj', False)
    os.chdir(sourceDir + '/gcc_obj')
    ice.utils.shell(sourceDir + '/' + gccName + '/configure -v --prefix="' + installDir + '" --target=mingw32 --with-headers="' + installDir + '/mingw32/include" --with-gcc --with-gnu-ld --with-gnu-as --enable-threads --disable-nls --enable-languages="c" --disable-win32-registry --disable-shared --enable-sjlj-exceptions --without-x', False)
    
    # build gcc core
    ice.utils.shell('make CFLAGS="-O2" CXXFLAGS="-O2"', False)
    ice.utils.shell('make install', False)
    os.chdir(oldcwd)
    
def ffmpegbTarget():
    #This target builds the pre-built windows .dll binaries with mingw
    crossCompilerDir = os.path.abspath('temp/mingw/cc/bin')
    sourceDir = os.path.abspath('temp/ffmpeg/mingw')
    installDir = os.path.abspath('temp/ffmpeg/mingw/install')

    # remove old build
    ice.utils.rmdir(os.path.abspath('temp/ffmpeg/mingw'), False)

    # extract ffmpeg sources
    ice.utils.mkdir(sourceDir, False)
    tarObject = tarfile.open('ffmpeg/source/ffmpeg_source.tar.bz2')
    ffmpegName = tarObject.next().name
    tarObject.extractall(sourceDir)
    tarObject.close()

    #build ffmpeg with mingw cross-compiler
    oldcwd = os.getcwd()
    os.chdir(sourceDir + '/' + ffmpegName)
    ffmpegBuildScript = """
    configure --enable-static --prefix=""" + installDir + """ --cross-prefix=mingw32- --enable-cross-compile --target-os=mingw32 --disable-ssse3 --enable-memalign-hack --disable-network --disable-ipv6 --disable-bzlib --disable-ffplay --disable-ffserver --disable-ffmpeg --disable-debug 
    make
    make install
    """
    ice.utils.run('sh', ['-c', ffmpegBuildScript], True, {'PATH' : os.getenv('PATH') + ':' + crossCompilerDir})
    os.chdir(oldcwd)

    # copy the new .lib and header files to ffmpeg directory
    print "Copying win32 ffmpeg binaries\n"
    ice.copyifnewer.copyIfNewer(installDir + '/lib/libavutil.a', 'ffmpeg/lib/win32/avutil.lib', False)
    ice.copyifnewer.copyIfNewer(installDir + '/lib/libavcodec.a', 'ffmpeg/lib/win32/avcodec.lib', False)
    ice.copyifnewer.copyIfNewer(installDir + '/lib/libavformat.a', 'ffmpeg/lib/win32/avformat.lib', False)

    print "Copying ffmpeg headers since building pre-compiled binaries should update include\n"
    ice.copyifnewer.copyIfNewer(installDir + '/include/libavutil', 'ffmpeg/include/libavutil', False)
    ice.copyifnewer.copyIfNewer(installDir + '/include/libavcodec', 'ffmpeg/include/libavcodec', False)
    ice.copyifnewer.copyIfNewer(installDir + '/include/libavformat', 'ffmpeg/include/libavformat', False)

#########################################################

def ideTarget():
    """
           The --generator option is required. To find generators for
           the build system run: cmake --help
           
           Example:
           buildg3d proj --debug --generator="MinGW Makefiles"
           
           --generator="cmake generator"
                generator string supported by cmake on build system
           --debug / --release
                generate debug/release configuration (defaults to release)
           --install-dir=installDir
                sets installation target directory
                generated project will still have to make install target
           --build-dir=buildDir
                sets the build directory (defaults to ./build)

compilerTable = \
    {'vc6.0'    : 'Visual Studio 6',
     'vc7.0'    : 'Visual Studio 7',
     'vc7.1'    : 'Visual Studio 7 .NET 2003',
     'vc8.0'    : 'Visual Studio 8 2005',
     'vc9.0'    : 'Visual Studio 9 2009',
     'gcc'      : 'gcc',
     'xcode'    : 'XCode'}

                """

    # TODO: automatically configure the args based on the platform
    #    compilerName = compilerTable[args[1]]
    
    args = []
    projOptions, projArgs = getopt.getopt(args, '', ['debug', 'release',
      'generator=', 'build-dir=', 'install-dir='])
    
    buildDir = 'build'
    buildType = 'Release'
    installDir = ''
    buildGenerator = ''
    
    for opt, arg in projOptions:    
        if opt == '--generator':
            if windows:
                buildGenerator = '"' + arg + '"'
            else:
                buildGenerator = arg
            
        if opt == '--debug':
            buildType = 'Debug'

        if opt == '--build-dir':
            buildDir = arg

        if opt == '--install-dir':
            installDir = arg
            
    if buildGenerator == '':
        print '--generator option is required for proj target'
        return -1

    cmakeArgs = ['-G', buildGenerator, '-DCMAKE_BUILD_TYPE=' + buildType]
    if installDir != '':
        cmakeArgs.append('-DCMAKE_INSTALL_PREFIX="' + installDir + '"')
        
    curDir = os.getcwd();

    try:
      os.makedirs(buildDir)
    except OSError, e:
      if e.errno == errno.EEXIST:
        print "Build directory " + buildDir + " already exists..."
      else:
        print "Error: " + buildDir + " could not be created...  aborting."
        return -1 

    os.chdir(buildDir)
    cmakeArgs.insert(0, curDir)
    ret = run('cmake', cmakeArgs)
    os.chdir(curDir)
    return ret

################################################################################

def helpTarget():
    print """
buildg3d - Automated build system for G3D.

Syntax: 
    buildg3d [--config config-file] [--install [install-dir] target

    The targets are: help, clean, lib, test, doc, jar, ide, all, ffmpeg, src

If you are installing G3D, you want to run:

    buildg3d --install all

Options:
--config <config-file>
       By default, buildg3d tries to use ~/.icompile-buildg3d
       as a configuration file. If it does not exist, it tries
       .icompile.  This allows you to explicitly specify another
       .icompile file to use on Unix. This
       allows you to build G3D with different INCLUDE, LIBRARY,
       and compiler settings than you normally use for writing
       programs.  See the iCompile manual for more information.

--install [<install-dir>]
       After building, copy files to this location. The default
       install-dir is """ + libInstallDir + """.
       
TARGET     DESCRIPTION

all        clean + lib + test + jar + tools + doc

update     lib + tools + doc + jar 
           
lib        Build G3D, G3Dd, GLG3D, GLG3Dd and copy over headers. Also build
           all dependencies (e.g., zlib, libpng)

doc        Generate documentation using Doxygen

tools      Build gfxmeter and viewer applications and copy copyifnewer and icompile

jar        Build G3D.jar, the Java version of network and
           file access.

test       Build test and testd and then run both

clean      Delete all generated files

help       Display this message


DEVELOPER TARGETS (unsupported)

src        Build a sources zipfile (Win32 only)

ide        Generates Xcode, Visual Studio, and g++ Makefiles using cmake.

ffmpegb    Build precompiled Windows libraries for ffmpeg using a Unix 
           g++ cross-compiler.

ffmpegc    Build cross-compiler used during ffmpegb target

The return code of buildg3d is the return code of the last process it
launched (i.e., you can expect 0 on success).
"""

################################################################################

""" Copy generated files to libInstallDir and docInstallDir """
def install():

    copyIfNewer('build/' + platformName + '/bin', pathConcat(libInstallDir, 'bin'))
    copyIfNewer('build/' + platformName + '/include', pathConcat(libInstallDir, 'include'))
    copyIfNewer('build/' + platformName + '/lib', pathConcat(libInstallDir, 'lib'))
    copyIfNewer('build/G3D.jar', pathConcat(libInstallDir, 'lib/G3D.jar'))
    
    copyIfNewer('build/html',    pathConcat(docInstallDir, 'html'))
    copyIfNewer('build/data',    pathConcat(docInstallDir, 'data'))
    copyIfNewer('build/demos',   pathConcat(docInstallDir, 'demos'))
    
    return 0


################################################################################

def dispatchOnTarget(target, validTargets):
    found = 0
    code = 0
    for v in validTargets:
        if target == v.func_name:
            return v()

    print '"' + target + '" is not a valid build target (type "build help" to see all targets).'
    return -1


if __name__ == "__main__":
    if len(sys.argv) < 2:
        helpTarget()
        sys.exit(-1)
        
    t0 = time.time()
    
    code = dispatchOnTarget(sys.argv[1] + 'Target',
        [libTarget, cleanTarget, testTarget,
         docTarget, allTarget, srcTarget, toolsTarget,
         jarTarget, ideTarget, helpTarget, updateTarget, 
         ffmpegbTarget, ffmpegcTarget])

    if (code == 0) and (sys.argv[1] != 'help') and doInstall:
        install()
        
    t1 = time.time()
    print '%ds' % (t1 - t0)

    sys.exit(code)
