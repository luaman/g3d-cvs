#!/usr/bin/env python
# -*- python -*-
#
# See manual.html for documentation.  http://ice.sf.net
#
# Copyright 2003-2006 Morgan McGuire
# All rights reserved.
#
# morgan@cs.williams.edu
#
# Original concept by Morgan McGuire and Rob Hunter
#
# DO NOT MODIFY THIS SCRIPT.  EDIT ICE.TXT AND ~/.ICOMPILE TO CUSTOMIZE
# YOUR PROJECT CONFIGURATION.

version = [0, 5, 0]

import sys, string, os, os.path, fileinput, tempfile, shutil, re
import commands, pickle, time
from sets import Set
from platform import machine
from string import ljust

from icehelp import *
from icevariables import *
from icedoticompile import *
from iceutils import *
from icedoxygen import *
from icelibrary import *
import icecopyifnewer
from icecopyifnewer import copyIfNewer
from icetopsort import *

if int(sys.version[:string.find(sys.version, '.')]) < 2:
    print ('iCompile requires Python 2.0 or later.  You are running Python '
           + sys.version)
    sys.exit(-10)

#########################################################################

""" Returns true if this is a cpp source filename. """
def isCFile(file):
    ext = string.lower(extname(file))

    return ((ext == 'cpp') or
           (ext == 'c') or
           (ext == 'c++') or
           (ext == 'cxx') or
           (ext == 'i') or
           (ext == 'ii') or
	   ((os.uname()[0] == 'Darwin') and
            ((ext == 'mm') or
             (ext == 'm') or
             (ext == 'mi') or
             (ext == 'mii'))))

#########################################################################

"""
A regular expression matching files that should be excluded from compilation
"""
excludeFromCompilation = None

def listCFilesVisitor(result, dirname, files):
    dir = dirname

    # Strip any unnecessary "./"
    if (dirname[:2] == "./"):
        dir = dir[2:]

    if ((excludeFromCompilation != None) and
        (excludeFromCompilation.search(dir) != None)):
        # Don't recurse into subdirectories of excluded directories
        del files[:]
        return

    # We can't modify files while iterating through it, so
    # we must make a list of all files that are to be removed before the
    # next iteration of the visitor.   
    removelist = [];
    for f in files:
         if ((excludeFromCompilation != None) and
             (excludeFromCompilation.search(f) != None)):
            if verbosity >= VERBOSE: print "  Ignoring '" + f + "'"
            removelist.append(f)
            
         elif isCFile(f):
             
            # Ensure the path ends in a slash (when needed)
            filename = pathConcat(dir, f)

            if ((excludeFromCompilation == None) or
                (excludeFromCompilation.search(filename) == None)):
                result.append(filename)

    # Remove any subdir in files that is itself excluded to prevent
    # later recursion into it.
    for f in removelist:
        files.remove(f)


"""Returns all files with gcc-recognized c/c++ endings for the given directory
   and all subdirectories.
   
   Filenames must be relative to the "rootDir" directory.  dir will be
   a subdirectory of rootDir.

   exclude must be a regular expression for files to exclude.
   """
def listCFiles(dir = '', exclude = None):
    if (dir == ''): dir = './'

    excludeFromCompilation = exclude
    result = []

    os.path.walk(dir, listCFilesVisitor, result)
    return result
   
##############################################################################
#                            Cache Management                                #
##############################################################################

""" Loads the icompile cache that preserves values between calls """
def loadCache(filename):
    global state

    if verbosity >= TRACE: print "Loading cache from " + filename + "\n"

    if os.path.exists(filename):
        file = open(filename, 'r')
        try:
            state.cache = pickle.load(file);
        except:
            # The cache was corrupted; ignore it
            state.cache = {}
            if verbosity >= NORMAL: 
                print "Internal iCompile cache at '" + filename + "' corrupted."

        if verbosity >= TRACE: print "cache = ", state.cache


        file.close()
    else:
        state.cache = {}

##############################################################################

def saveCache(filename):
    file = open(filename, 'w')
    pickle.dump(state.cache, file)
    file.close()

##############################################################################
#                            Discover Platform                               #
##############################################################################

def discoverPlatform(state):

    state.os = ''
    compiler = ''

    # Figure out the os
    if (os.uname()[0] == 'Linux'):
        state.os = 'linux'
    elif (os.uname()[0] == 'FreeBSD'):
        state.os = 'freebsd'
    elif (os.uname()[0] == 'Darwin'):
        state.os = 'osx'
    else:
        raise 'Error', 'iCompile only supports Linux and OS X'

    # Figure out the compiler
    c = state.compiler
    compiler = betterbasename(c)

    if compiler.startswith('g++') or compiler.startswith('gcc'):
        compiler = 'g++'

    # Append the major and minor compiler version number to the compiler name
    v = getVersion(c)    
    if len(v) > 2:
        v = v[0:2]
    if len(v) < 2:
        # Version number was short; add a 0 minor number
        v = v + 0
    compiler += string.join(map(str, v), '.')

    state.platform = state.os + '-' + machine() + '-' + compiler
    
##############################################################################
#                            Build Documentation                             #
##############################################################################

def buildDocumentation():
    maybeColorPrint('Building documentation', SECTION_COLOR)

    # See if there is a Doxygen file already
    if not os.path.exists(state.rootDir + 'Doxyfile'):
        print ("Your project does not have a 'Doxyfile' file, so iCompile " +
               "will now create one for you.\n")
        createDoxyfile()
        print "Done creating 'Doxyfile'\n\n"

    run("doxygen", ["Doxyfile"])

    if (os.path.exists(state.rootDir + 'doc-files')):
        copyIfNewer(rootDir + 'doc-files', 
                    rootDir + state.buildDir + 'doc', 
                    verbosity >= VERBOSE)

    maybeColorPrint('Done building documentation', SECTION_COLOR)

##############################################################################
#                               Build Data Files                             #
##############################################################################

def buildDataFiles():
    src = 'data-files'
    dst = state.buildDir + 'install/'
    
    if os.path.exists(src):
        if verbosity >= NORMAL: colorPrint('\nCopying data files', SECTION_COLOR)
        copyIfNewer(src, dst, verbosity >= VERBOSE, verbosity == NORMAL)
        if verbosity >= VERBOSE: colorPrint('Done copying data files', SECTION_COLOR)

##############################################################################
#                               Build Include                                #
##############################################################################
""" Copies headers to the build directory. """
def buildInclude():
    src = 'include'
    dst = state.buildDir + 'install/include'
    
    if os.path.exists(src):
        if verbosity >= NORMAL: colorPrint('\nCopying public header files', SECTION_COLOR)
        copyIfNewer(src, dst, verbosity >= VERBOSE, verbosity >= NORMAL)
        if verbosity >= VERBOSE: colorPrint('Done copying public header files', SECTION_COLOR)

##############################################################################
#                                 Build Clean                                #
##############################################################################

def buildClean():
    if verbosity >= NORMAL: colorPrint('Deleting all generated files', SECTION_COLOR)
    
    rmdir(state.rootDir + state.buildDir, verbosity >= VERBOSE)
    rmdir(state.rootDir + state.tempDir, verbosity >= VERBOSE)

    if verbosity >= VERBOSE: colorPrint('Done deleting generated files\n', SECTION_COLOR)


#########################################################################

"""Returns a list of *all* files on which this file depends (including
   itself).  Returned filenames must either be fully qualified or
   relative to the "rootDir" dir.

   May modify the default compiler and linker options
   """
def getDependencies(file, iteration = 1):
    global state

    # We need to use the -msse2 flad during dependency checking because of the way
    # xmmintrin.h is set up
    #
    # -MG means "don't give errors for header files that don't exist"
    # -MM means "don't tell me about system header files"
    raw = shell(state.compiler + ' -M -msse2 -MG ' +
                string.join(getCompilerOptions([]), ' ') + ' ' + file,
                verbosity >= VERBOSE)

    if verbosity >= TRACE:
        print raw

    if raw.startswith('In file included from'):
        # If there was an error, the output will have the form
        # "In file included from _____:" and a list of files
        
        if iteration == 3:
            # Give up; we can't resolve the problem
            print raw
            sys.exit(-1)
        
        if verbosity >= VERBOSE:
            print ('\nThere were some errors computing dependencies.  ' +
                   'Attempting to recover.('), iteration,')'
        
        # Generate a list of files and see if they are something we
        # know how to fix.
        noSuchFile = []
        for line in string.split(raw, '\n'):
            if line.endswith(': No such file or directory'):
                x = line[:-len(': No such file or directory')]
                j = x.rfind(': ')
                if (j >= 0): x = x[(j+2):]

                # x now has the filename
                noSuchFile.append(betterbasename(x))

        if verbosity >= NORMAL: print 'Files not found:', noSuchFile
        
        # Look for files we know how to handle
        for f in noSuchFile:
            if f == 'wx.h':
                if verbosity >= NORMAL: print 'wxWindows detected.'
                state.compilerOptions.append(shell('wx-config --cxxflags', verbosity >= VERBOSE))
                state.linkerOptions.append(shell('wx-config --gl-libs --libs', verbosity >= VERBOSE))
                
        return getDependencies(file, iteration + 1)

    else:

        # Normal case, no error
        if 'implemented' in raw: print raw
        result = []
        raw = raw.replace('\\', ' ')
        for line in raw.splitlines():
            # gcc 3.4.2 likes to print the name of the file first, as in
            # """# 1 "/home/faculty/morgan/Projects/ice/tests/meta/helper.lib//""""
            if not line.startswith('# '):
                result += string.split(line, ' ')

        # There is always at least one file since everything depends on itself.
        
        # The first element of result will be "file:", so strip it
        files = result[1:]
        result = []

        # Add the './' to raw files
        for f in files:
            f = f.strip()
            if '/' in f:
                result.append(f)
            elif f == '':
                # empty filename
                files.remove(f)
            else:
                result.append('./' + f)

        return result


#########################################################################

"""Finds all of the C++/C files in rootDir and returns
 dependency information for them as the tuple
 
   (allCFiles, dependencies, allDependencyFiles, parents)

 where: 
 
 allCFiles is the list of all source files to compile,

 dependencies[f] is the list of all files on which
 f depends,

 allDependencyFiles is the list of all files
 on which *any* file depends, and

 parents[f] is the list of all files that depend on f

 While getting dependencies, this may change the include/library
 list and restart the process if it appears that some include
 directory is missing.
"""
def getDependencyInformation():
    
    # Hash table mapping C files to the list of all files
    # on which they depend.
    dependencies = {}

    parents = {}

    # All files on which something depends
    dependencySet = Set()

    # Find all the c files
    allCFiles = listCFiles(state.rootDir, state.excludeFromCompilation)

    if verbosity >= TRACE: print 'Source files found:', allCFiles

    # Get their dependencies
    for cfile in allCFiles:

        # Do not use warning or verbose options for this; they
        # would corrupt the output.
        dlist = getDependencies(cfile)

        # Update the dependency set
        for d in dlist: 
            dependencySet.add(d)
            if d in parents:
                parents[d] += cfile
            else:
                parents[d] = [cfile]
 
        dependencies[cfile] = dlist
    
    # List of all files on which some other file depends
    dependencyFiles = [d for d in dependencySet]

    return (allCFiles, dependencies, dependencyFiles, parents)

#########################################################################

"""Given a source file (relative to rootDir) returns an object file
  (relative to rootDir).
"""
def getObjectFilename(sourceFile):
    # strip the extension and replace it with .o
    i = string.rfind(sourceFile, '.')
    return state.objDir + sourceFile[len(state.rootDir):i] + '.o'

#########################################################################

def getOutOfDateFiles(cfiles, dependencies, files):
    # Get modification times for all of the files
    timeStamp = {}
    for file in files:
        timeStamp[file] = getTimeStamp(file)
    
    buildList = []
    
    # Need to rebuild all if this script was modified more
    # recently than a given file.
    icompileTime = getTimeStamp(sys.argv[0])

    # Rebuild all if ice.txt or .icompile was modified
    # more recently.
    if os.path.exists('ice.txt'):
        iceTime = getTimeStamp('ice.txt')
        if iceTime > icompileTime:
            icompileTime = iceTime

    HOME = os.environ['HOME']
    preferenceFile = pathConcat(HOME, '.icompile')
    if os.path.exists(preferenceFile):
        configTime = getTimeStamp(preferenceFile)
        if configTime > icompileTime:
            icompileTime = configTime


    # Generate a list of all files newer than their targets
    for cfile in cfiles:
        ofile = getObjectFilename(cfile)
        otime = getTimeStamp(ofile)
        rebuild = (otime < icompileTime)

        if rebuild and verbosity >= TRACE:
            print "iCompile is newer than " + ofile

        if not rebuild:
            # Check dependencies
            for d in dependencies[cfile]:
                dtime = timeStamp[d]
                if otime < dtime:
                    if verbosity >= TRACE:
                        print d + " is newer than " + ofile
                    rebuild = 1
                    break

        if rebuild:
            # This file needs to be rebuilt
            buildList.append(cfile)

    return buildList

#########################################################################

"""allFiles is a list of all files on which something
   depends for the project.

   Returns a list of strings

   extraOpts are options that are needed for compilation
   but not dependency checking:
     state.compilerWarningOptions + state.compilerVerboseOptions
   """
def getCompilerOptions(allFiles, extraOpts = []):
    opt = state.compilerOptions + extraOpts + ['-c']
    
    for i in state.includePaths():
        opt += ['-I' + i]

    # See if the xmm intrinsics are being used
    # This was disabled because -msse2 allows code generation,
    # not just explicit use of intrinsics
    #for f in allFiles:
    #    if f[-11:] == 'xmmintrin.h':
    #        opt += ['-msse2']
    #        break
        
    return opt

""" Compiles the source file. """
def makeObjectFile(cfile, options):
    ofile = getObjectFilename(cfile)
   
    # Create the directory for the ofile as needed
    i = ofile.rfind("/")
    if (i >= 0):
        mkdir(ofile[:i], verbosity >= VERBOSE)

    args = string.split(options) 
  
    if (extname(cfile).lower() == 'c'):
        # At least on Darwin, g++ (vs. gcc) fails to correctly
        # identify c files with old syntax (e.g., png.c) and
        # needs an explicit language argument.
        args += ['-x', 'c']

    args += ['-o', ofile, cfile]

    if verbosity == NORMAL:
        # 'run' will not print the full command, so we just
        # print filename to be compiled here.

        print shortname(cfile)

    ret = run(state.compiler, args, verbosity > NORMAL)

    if ret != 0:
        sys.exit(ret)
    else:
        if verbosity >= VERBOSE: print

#########################################################################

"""Mutates dynamicLinkFiles to contain additional libraries that are probably
needed by the staticLinkFiles.  Called from getLinkerOptions.
"""
def getAdditionalDynamicLinks(dynamicLinkFiles, staticLinkFiles):
    if verbosity >= TRACE: print '\nBegin getAdditionalDynamicLinks'
    
    # Static files may have their own dependencies.  We track these down by
    # looking at symbols defined in the library and seeing which ones map
    # to common dynamic libraries.
    for file in staticLinkFiles:
        sfile = findLibrary(file, STATIC, state.libraryPaths())
        if os.path.exists(sfile):
            cmd = 'nm --extern-only --demangle --undefined-only ' + sfile
            if verbosity >= VERBOSE: colorPrint(cmd, COMMAND_COLOR)

            symbols = string.split(commands.getoutput(cmd))

            for symbol in symbols:
                if extraLink.has_key(symbol):
                    (debug, release) = extraLink[symbol]

                    if state.target == DEBUG:
                        lfile = debug
                    else:
                        lfile = release
             
                    if verbosity >= TRACE:
                        print (symbol + " in " + sfile +
                              " triggered dynamic link against " + lfile)

                    if not (lfile in dynamicLinkFiles):
                        dynamicLinkFiles.append(lfile)

    if verbosity >= TRACE: print 'End getAdditionalDynamicLinks\n'


""" Add the dependencies from the libraries list (recursively)
    libraries must be a set of canonical library names
"""
def extendLibrariesWithDependencies(libraries):
    # Start with an initial list of all libraries
    stack = [libname for libname in libraries]

    # Keep looping as long as we added something
    while len(stack) > 0:
        libname = stack.pop()
        
        if libraryTable.has_key(libname):
            for dependency in libraryTable[libname].dependsOnList:
                if not dependency in libraries:
                    # This is a new dependency, add it to both the process
                    # stack and to the set of libraries
                    libraries.add(dependency)
                    stack.append(dependency)

"""allFiles is a list of all files on which something
   depends for the project. """
def getLinkerOptions(allFiles):
    opt = state.linkerOptions

    opt += [('-L' + path) for path in state.libraryPaths()]

    # Set of canonically named libraries to link against
    libraries        = Set()

    # Compute a list of all libraries needed from the headers
    for path in allFiles:
        header = betterbasename(path)
    
        if headerToLibraryTable.has_key(header):
            libs = headerToLibraryTable[header]
            libraries.update(libs)
                
            if verbosity >= TRACE:
                if len(libs) > 1:
                   print '#include "' + header + '" triggered links to ' + libs
                elif len(libs) > 0:
                   print '#include "' + header + '" triggered a link to ' + libs[0]

    # Add the dependencies from the libraries list
    extendLibrariesWithDependencies(libraries)
    
    # Check for additional libraries that will be needed from the
    # symbols in the static libraries on which we depend.
    # TODO:

    # Since we may have just changed the list of libraries, re-extend it
    # with dependencies
    # TODO:     extendLibrariesWithDependencies(libraries)

    # Topologically sort library list to satisfy linker ordering
    libList = [libname for libname in libraries]
    if verbosity >= TRACE: print 'Libraries before sort: ', libList
    sortLibraries(libList)
    if verbosity >= TRACE: print 'Libraries after sort: ', libList

    # Separate into static libs, dynamic libs, and frameworks
    allLinks = []

    for libname in libList:
        if libraryTable.has_key(libname):
            lib = libraryTable[libname]

            if state.target == DEBUG:
                if state.os == 'osx' and lib.debugFramework != None:
                    allLinks += ['-framework',  lib.debugFramework]
                elif (lib.type != FRAMEWORK) and (lib.debugLib != None):
                    allLinks += ['-l' + rawLibraryFilename(findLibrary(lib.debugLib, lib.type, state.libraryPaths()))]
            else:
                if state.os == 'osx' and lib.releaseFramework != None:
                    allLinks += ['-framework',  lib.releaseFramework]
                elif (lib.type != FRAMEWORK) and (lib.releaseLib != None):
                    allLinks += ['-l' + rawLibraryFilename(findLibrary(lib.releaseLib, lib.type, state.libraryPaths()))]

        elif verbosity >= NORMAL:
            colorPrint("Detected use of the '" + libname + 
                      "' library, which iCompile does not know how to use.", WARNING_COLOR)

    # Add libraries on which we explicitly depend
    #suffix = ''
    #if state.target == DEBUG:
    #    suffix = 'd'

    #for u in usesProjectsList:
    #    if u.endswith('/'):
    #        u = u[:-1]
    #    libname = rawfilename(u) + suffix
    #    allLinks.append('-l' + libname)

    # If SDL is already on the link list then it automatically links X11
    # so avoid explicit link
    #if ('SDL' in allLinks) and ('X11' in allLinks):
    #    allLinks.remove('X11')

    if verbosity >= TRACE:
        print 'Library link options: ', allLinks
    
    return opt + allLinks

#########################################################################

""" Makes a static library from a list of object files and libraries."""
def makeStaticLibrary(objectFiles):
    if verbosity >= QUIET: colorPrint("\nCreating static library", SECTION_COLOR)

    ret = run('ar', ['cr', state.binaryDir + state.binaryName] + objectFiles, verbosity >= VERBOSE)
    if verbosity >= VERBOSE: print
    
    if (ret == 0):
        ret = run('ranlib', [state.binaryDir + state.binaryName], verbosity >= VERBOSE)


#########################################################################

""" Makes an executable from a list of object files. 
    """
def makeExecutable(objectFiles, linkOptions):

    # Create the command line arguments for the linker.
    # Note that the object files must come first
    options = []
    
    if (os.uname()[0] == 'Darwin'):
        filelistFileName = state.tempDir + 'filelist.txt'

        # Write the object file list
        f = open(filelistFileName, 'w')
        newline = '\n'
        f.write(string.join(objectFiles, newline) + newline)
        f.close()

        options += ['-filelist', filelistFileName]
    else:
        options += objectFiles

    options += linkOptions + ['-o', state.binaryDir + state.binaryName]

    if ('OpenGL' in options) or ('GL' in options):
        # Suppress the multiply defined symbols warning that 
        # comes from using OpenGL (which has both dynamic and static
        # versions of the same functions)
        options += ['-multiply_defined', 'suppress']
 
 	if (os.uname()[0] == 'Darwin'):
            # Linking OpenGL on Darwin creates problems because of the
	    # framework.  This option appears to work around the problem.
	    options += ['-all_load']

    if verbosity >= NORMAL: colorPrint('\nLinking', SECTION_COLOR)

    print options
    ret = run(state.compiler, options, verbosity >= VERBOSE)

    if ret != 0:
        sys.exit(ret)
    elif (state.target == RELEASE):
        # Strip debug symbols
	run('strip', [state.binaryDir + state.binaryName], verbosity >= VERBOSE)

#########################################################################

""" Returns sibling directories that are also iCompile libraries as names
    relative to the current directory.
    Allowed to recurse back two parent directories"""
def getLibrarySiblingDirs(howFarBack = 1):
    libsibs = []
    for dir in getSiblingDirs(howFarBack):

        # See if it contains an ice.txt and ends in a library extension
        ext = extname(dir).lower()
        if (os.path.exists(dir + '/ice.txt') and 
           ((ext == 'lib') or (ext == 'a') or 
            (ext == 'so') or  (ext == 'dll'))):
            libsibs.append(dir)

    return libsibs


"""
"""
def shortname(cfile):
    if cfile.startswith(state.rootDir):
        # Don't bother printing the root directory name
        # when it appears
        return cfile[len(state.rootDir):]
    else:
        return cfile


""" Creates the object files and links them. """
def buildBinary():
    global state

    if verbosity >= NORMAL: 
        printBar()
        colorPrint('Building ' + state.binaryName, SECTION_COLOR)

    # Create the temp directory for object files
    mkdir(state.objDir, verbosity >= VERBOSE)

    if verbosity >= VERBOSE: colorPrint('Computing dependencies', SECTION_COLOR)
    (cfiles, dependencies, files, parents) = getDependencyInformation()

    # See if any of the header files are not found; that might imply
    # sibling project is an implicit dependency.
    # Include the empty path on this list so that we'll find files
    # that are fully qualified as well as files in the current directory.
    # This list will be extended as we go forward.
    incPaths = [''] + state.includePaths()
    librarySiblingDirs = getLibrarySiblingDirs(3)

    for header in files:
        found = False
        i = 0
        while not found and (i < len(incPaths)):
            found = os.path.exists(pathConcat(incPaths[i], header))
            i += 1

        if not found:
            # This header doesn't exist in any of the standard include locations.
            # See if it is in a sibling directory that is a library.
            i = 0

            while not found and (i < len(librarySiblingDirs)):
                dirname = librarySiblingDirs[i]
                found = os.path.exists(dirname + '/include/' + header)
                if found:
                    if verbosity >= TRACE: print "Found '" + header + "' in '" + dirname + "/include'."
                    # We have identified a sibling library on which this project appears
                    # to depend.  

                    type = EXE
                    libname = rawfilename(dirname)
                    ext = extname(dirname).lower()
                    if ext == 'dll' or ext == 'so':
                        type = DLL
                    elif ext == 'lib' or ext == 'a':
                        type = LIB

                    if isLibrary(type):
                        if not libraryTable.has_key(libname):
                           defineLibrary(Library(libname, type, libname, libname + 'd',  
	                                         None,  None, [betterbasename(header)], [], []))

                        if not libname in state.usesLibrariesList:
                            state.usesLibrariesList.append(libname)

                        if not dirname in state.usesProjectsList:
                            print ('Detected dependency on ' + dirname + ' from inclusion of ' + 
                                   header + ' by'), shortname(parents[header][0])

                            state.usesProjectsList.append(dirname)

                            # Load the configuration state for the dependency project
                            curDir = os.getcwd()
                            os.chdir(dirname)
                            other = getConfigurationState(state.args)
                            os.chdir(curDir)

                            state.addIncludePath(pathConcat(dirname, 'include'))
                            state.addLibraryPath(pathConcat(dirname, other.binaryDir))
                            
                            incPaths.append(dirname + '/include/') # TODO: why maintain a separate incPath here vs. state.includePaths?
                            # TODO: recursively add all dependencies that come from this new header/library
                i += 1

        if not found:
            maybeWarn("Header file not found: '" + header + "'.", state)


    if verbosity >= TRACE:
        print 'Header files #included:'
        for f in files:
            print '  ' + f
        print

    if cfiles == []:
        print
        print "No C or C++ files found."
        sys.exit(-10)

    # Build all projects on which we depend
    #for lib in state.usesProjectsList:
    # TODO

    buildList = getOutOfDateFiles(cfiles, dependencies, files)

    copt = string.join(getCompilerOptions(files, state.compilerWarningOptions + state.compilerVerboseOptions), ' ')

    if verbosity >= TRACE:
        print "\nBuilding out of date files\n"    

    # Build all out of date files
    if (buildList != []):
        if verbosity >= NORMAL: colorPrint('\nCompiling', SECTION_COLOR)
    
    for file in buildList:
        makeObjectFile(file, copt)
        relink = 1
 
    # Generate *all* object file names (even ones that
    # aren't rebuilt
    ofiles = []
    for cfile in cfiles: 
        ofiles.append(getObjectFilename(cfile))

    # Definitely need to link if no executable exists
    doLink = not os.path.exists(state.binaryDir + state.binaryName)
    if not doLink:
        # See if an object file is newer than the exe
        
        exeTime = getTimeStamp(state.binaryDir + state.binaryName)
        for file in ofiles:
            if getTimeStamp(file) > exeTime:
                if verbosity >= TRACE:
                    print ("Relinking because " + file + 
                           " is newer than " + state.binaryDir + state.binaryName)
                doLink = True
                break

    # Only link when necessary
    if doLink:
        if not os.path.exists(state.binaryDir):
            mkdir(state.binaryDir, verbosity >= VERBOSE)

        if ((state.binaryType == EXE) or
            (state.binaryType == DLL)):

            # Dynamic library or executable.
            lopt = getLinkerOptions(files)
            makeExecutable(ofiles, lopt)

        else:

            # Static library.
            makeStaticLibrary(ofiles)

    if verbosity >= VERBOSE: colorPrint('Done building ' + state.binaryName, SECTION_COLOR)
    
#########################################################################

#########################################################################

""" Returns two lists; all of the arguments up to and including the first
"--run" or "--gdb" and all arguments to the right."""
def separateArgs(args):
    for i in xrange(0, len(args)):
        if (args[i] == "--run") or (args[i] == "--gdb"):
            progArgs = args[(i + 1):]
            args = args[:(i + 1)]
            return (args, progArgs)
    return (args, [])


#########################################################################
""" Called from runCompile to launch the program on completion.  Returns
    the program's exit code. """
def runCompiledProgram(progArgs):
    printBar()
    curDir = os.getcwd()
    os.chdir(state.binaryDir)
    cmd = './' + state.binaryName + ' ' + string.join(progArgs, ' ')
    ret = os.system(cmd)
    os.chdir(curDir)
    return ret


#########################################################################

""" Called from runCompile to launch the program on completion.  Returns
    the program's exit code. """
def gdbCompiledProgram(progArgs):
    # Write out the 'run' command to a file since gdb doesn't
    # accept it on the command line.
    commandFile = state.tempDir + 'gdb-commands.txt'
    f = open(commandFile, 'w')
    f.write('run ' + string.join(progArgs, ' '))
    f.close()

    # Options: -q   Don't print copyright info
    #          -x   Run the gdb commands we wrote out to the command file
    #          -cd  Working directory
    #          -f   Print files and line numbers in Emacs-compatible format
    cmd = ('gdb -x ../../' + commandFile + ' -cd ' + state.binaryDir +
                ' -q -f ' + state.binaryName)
    print cmd
    printBar()
    return os.system(cmd)

##########################################################################

""" Checks for ice.txt and, if not found, prompts the user to create it
    and returns if they press Y, otherwise exits."""
def checkForProjectFile(state, args):
    # Assume default project file
    projectFile = 'ice.txt'
    if os.path.exists(projectFile): return

    # Everything below here executes only when there is no project file
    if not state.noPrompt:

        if ('--clean' in args) and not os.path.exists(state.buildDir):
            print
            colorPrint('Nothing to clean (you have never run iCompile in ' +
                   os.getcwd() + ')', WARNING_COLOR)
            print
            # Doesn't matter, there's nothing to delete anyway, so just exit
            sys.exit(0)

        print
        inHomeDir = (os.path.realpath(os.getenv('HOME')) == os.getcwd())

        if inHomeDir:
            colorPrint(' ******************************************************',
                       WARNING_COLOR)
            colorPrint(' * You are about run iCompile in your home directory! *',
                       'bold red')
            colorPrint(' ******************************************************',
                       WARNING_COLOR)
        else:        
            colorPrint('You have never run iCompile in this directory before.',
                       WARNING_COLOR)
        print
        print '  Current Directory: ' + os.getcwd()
    
        # Don't show dot-files first if we can avoid it
        dirs = listDirs()
        dirs.reverse()
        num = len(dirs)
        sl = shortlist(dirs)
    
        if (num > 1):
            print '  Contains', num, 'directories (' + sl + ')'
        elif (num > 0):
            print '  Contains 1 directory (' + dirs[0] + ')'
        else:
            print '  Contains no subdirectories'

        cfiles = listCFiles()
        num = len(cfiles)
        sl = shortlist(cfiles)
    
        if (num > 1):
            print '  Subdirectories contain', num, 'C++ files (' + sl + ')'
        elif (num > 0):
            print '  Subdirectories contain 1 C++ file (' + cfiles[0] + ')'
        else:
            print '  Subdirectories contain no C++ files'    

        print
    
        dir = string.split(os.getcwd(), '/')[-1]
        if inHomeDir:
            prompt = ('Are you sure you want to run iCompile '+
                      'in your home directory? (Y/N)')
        else:
            prompt = ("Are you sure you want to compile the '" +
                      dir + "' project? (Y/N)")
        
        colorPrint(prompt, 'bold')
        if string.lower(getch()) != 'y':
            sys.exit(0)
        
    f = file(projectFile, 'wt')
    f.write(defaultProjectFileContents)
    f.close()
    

#################################################################
        
""" Choose and configure the compiler for this platform and target."""
def configureCompiler():
    configureGpp()


""" Configure g++ as our compiler of choice.
    Called from configureCompiler."""
def configureGpp():
    global state

    userCompilerOptions = state.compilerOptions
    userLinkerOptions = state.linkerOptions

    if (state.target == RELEASE):
        state.compilerOptions = ['-O3',
                                 '-D_RELEASE', 
                                 '-fno-trapping-math',
                                 '-s']
        # Had to remove '-fno-math-errno' because g++ occasionally
        # crashes with that option.

        # Removed '-fno-finite-math-only' because it is not supported
        # by g++3.2

        state.linkerOptions   = []
    else:
        state.compilerOptions = ['-D_DEBUG', '-g']
        state.linkerOptions   = []

    if state.os == 'linux':
       # LARGEFILE_SOURCE enables some newer interfaces for
       # fopen that work with >2GB files
       flags = shell('getconf', ['LFS_CFLAGS'], verbosity >= VERBOSE)
       state.compilerOptions += string.split(flags, ' ')

    if (os.uname()[0] == 'Darwin'):
        universalBinary = False # TODO: Add universal binary support for libraries later

        # Not supported on OS X
        state.compilerOptions += ['-D__cdecl=', '-D__stdcall=']

        # needed for inline asm on OS X
        state.compilerOptions.append('-fasm-blocks')

        arch = []
        if universalBinary:
            # on an intel machine we can compile for both ppc and intel
            # but on a ppc machine we use the defaults and compile only for ppc
            if (machine() == 'i386'):
                arch = ['-arch', 'i386', '-arch', 'ppc']
        else:
            if (machine() == 'i386'):
                arch = ['-arch', 'i386']
            else:
                arch = ['-arch', 'ppc']

        state.compilerOptions += arch
        state.linkerOptions   += arch 

    # Use pipes instead of temporary files for 
    # inter-process communication; this should be faster.
    state.compilerOptions += ['-pipe']
 
    if (state.binaryType == DLL):
        state.linkerOptions  += ['-shared']

    state.compilerWarningOptions = ['-Wall', '-Wformat=2']
  
    # Put user options last so that they can override ours
    state.compilerOptions += userCompilerOptions
    state.linkerOptions += userLinkerOptions

    # Remove empty arguments (they will confuse the linker)
    while '' in state.linkerOptions:
        state.linkerOptions.remove('')


#########################################################################

""" Main program execution.
  Returns the exit code of the build process.
  args     - arguments to iCompile
  progArgs - arguments to pass on to the compiled program
"""
def main(args, progArgs, doGDB, doRun):
    if ("--clean" in args):
        buildClean()
        # Exit early, preventing the cache from being written
        sys.exit(0)
    
    if ("--doc" in args):
        buildDocumentation()
        maybePrintBar()

    if state.binaryType == EXE:
        buildDataFiles()
        maybePrintBar()
        
    buildBinary()

    maybePrintBar()
        
    if isLibrary(state.binaryType):
        buildInclude()
        maybePrintBar()
    
    if doGDB:
        return gdbCompiledProgram(progArgs)

    if doRun:
        return runCompiledProgram(progArgs)

    if not (doGDB or doRun) and (verbosity >= NORMAL):
        if (state.binaryType == EXE):
            print '\nExecutable written to ' + state.binaryDir + state.binaryName
        else:
            print '\nLibrary written to ' + state.binaryDir + state.binaryName
                
    return 0

###############################################################


# Loads configuration from the current directory, where args
# are the arguments preceding --run that were passed to iCompile
#
# Returns the configuration state
def getConfigurationState(args):
    
    state = State()

    state.args = args

    state.noPrompt = '--noprompt' in args

    # Root directory
    state.rootDir                    = os.getcwd() + "/"

    # Project name
    state.projectName                = string.split(state.rootDir, ('/'))[-2]

    ext = string.lower(extname(state.projectName))
    state.projectName = rawfilename(state.projectName)

    # Binary type    
    if (ext == 'lib') or (ext == 'a'):
        state.binaryType = LIB
    elif (ext == 'dll') or (ext == 'so'):
        state.binaryType = DLL
    elif (ext == 'exe') or (ext == ''):
        state.binaryType = EXE
    else:
        state.binaryType = EXE
        maybeWarn("This project has unknown extension '" + ext +
                  "' and will be compiled as an executable.", state)

    # Choose target
    if ('--opt' in args) or ('-O' in args):
        if ('--debug' in args):
            colorPrint("Cannot specify '--debug' and '--opt' at " +
                       "the same time.", WARNING_COLOR)
            sys.exit(-1)

        state.target          = RELEASE
        d                     = ''
    else:
        state.target          = DEBUG
        d                     = 'd'

    # Find an icompile project file.  If there isn't one, give the
    # user the opportunity to create one or abort.
    checkForProjectFile(state, args)

    # Load settings from the project file.
    processProjectFile(state)

    discoverPlatform(state)

    unix = not state.os.startswith('win')

    # On unix-like systems we prefix library names with 'lib'
    prefix = ''
    if unix and isLibrary(state.binaryType):
        prefix = 'lib'

    # Binary name
    if (state.binaryType == EXE):
        state.binaryDir  = state.buildDir + 'install/'
        state.binaryName = state.projectName + d
    elif (state.binaryType == DLL):
        state.binaryDir  = state.buildDir + 'install/' + state.platform + '-lib/'
        state.binaryName = prefix + state.projectName + d + '.so'
    elif (state.binaryType == LIB):
        state.binaryDir  = state.buildDir + 'install/' + state.platform + '-lib/'
        state.binaryName = prefix + state.projectName + d + '.a'

    # Make separate directories for object files based on
    # debug/release
    state.objDir = state.tempDir + state.platform + '/' + state.target + '/'

    return state


#################################################################
# Entry point

if __name__ == '__main__':

    # Process global arguments and then invoke the actual build process

    (args, progArgs) = separateArgs(sys.argv[1:])

    # Set the global variables
    i = find(args, '--verbosity')
    if i > -1:
        if i < len(args) - 1:
            try:
                # Clamp verbosity to the legal levels
                verbosity = max(min(string.atoi(args[i + 1]) + QUIET, TRACE), QUIET)
            except ValueError:
                maybeWarn('WARNING: illegal --verbosity argument: ' + args[i + 1], state)
        else:
            maybeWarn('WARNING: --verbosity used without an argument', state)

    # --help and --version are processed immediately
    if ('--version' in args):
        printVersion()
        sys.exit(0)

    if ('--help' in args):
        printHelp()
        sys.exit(0)

    state = getConfigurationState(args)

    doGDB   = '--gdb' in args
    doRun   = '--run' in args

    if doGDB and doRun:
        colorPrint("Cannot specify both --gdb and --run options.", WARNING_COLOR)
        sys.exit(-1)

    if (doGDB or doRun) and (state.binaryType != EXE):
        colorPrint("Cannot specify --gdb or --run for a library.", WARNING_COLOR)
        sys.exit(-1)


    # Load cached dependencies for this project
    cacheFilename = state.tempDir + '.icompile-cache'
    loadCache(cacheFilename)

    configureCompiler()

    ret = main(args, progArgs, doGDB, doRun)

    mkdir(state.tempDir, verbosity >= VERBOSE)
    saveCache(cacheFilename)
    if (verbosity >= NORMAL) and state.beep:
        beep()

    sys.exit(ret)
