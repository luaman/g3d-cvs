#!/usr/bin/env python
# -*- python -*-
#
# See manual.html for documentation.  http://ice.sf.net
#
# Copyright 2003-2007 Morgan McGuire
# All rights reserved.
#
# morgan@cs.williams.edu
#
# Original concept by Morgan McGuire and Rob Hunter
#
# DO NOT MODIFY THIS SCRIPT.  EDIT ICE.TXT AND ~/.ICOMPILE TO CUSTOMIZE
# YOUR PROJECT CONFIGURATION.

version = [0, 5, 1]

import sys, string, os, os.path, fileinput, tempfile, shutil, re
import commands, pickle, time

from sets import Set
from platform import machine
from string import ljust

from ice.utils import *
from ice.depend import *
from ice.help import *
from ice.variables import *
from ice.doticompile import *
from ice.doxygen import *
from ice.library import *
import ice.copyifnewer
from ice.copyifnewer import copyIfNewer
from ice.topsort import *

if int(sys.version[:string.find(sys.version, '.')]) < 2:
    print ('iCompile requires Python 2.0 or later.  You are running Python '
           + sys.version)
    sys.exit(-10)

   
##############################################################################
#                            Cache Management                                #
##############################################################################

""" Loads the icompile cache that preserves values between calls """
def loadCache(state, filename):

    if verbosity >= TRACE: print "Loading cache from " + filename + "\n"

    if os.path.exists(filename):
        file = open(filename, 'r')
        try:
            state.cache = pickle.load(file);
        except:
            # The cache was corrupted; ignore it
            state.cache = {}
            if verbosity >= NORMAL: 
                print "Internal iCompile cache at '" + filename + "' corrupted."

        if verbosity >= TRACE: print "cache = ", state.cache


        file.close()
    else:
        state.cache = {}

##############################################################################

def saveCache(state, filename):
    file = open(filename, 'w')
    pickle.dump(state.cache, file)
    file.close()

    
##############################################################################
#                            Build Documentation                             #
##############################################################################

def buildDocumentation():
    maybeColorPrint('Building documentation', SECTION_COLOR)

    # See if there is a Doxygen file already
    if not os.path.exists(state.rootDir + 'Doxyfile'):
        print ("Your project does not have a 'Doxyfile' file, so iCompile " +
               "will now create one for you.\n")
        createDoxyfile()
        print "Done creating 'Doxyfile'\n\n"

    run("doxygen", ["Doxyfile"], verbosity >= VERBOSE)

    if (os.path.exists(state.rootDir + 'doc-files')):
        copyIfNewer(rootDir + 'doc-files', 
                    state.buildDir + 'doc', 
                    verbosity >= VERBOSE)

    maybeColorPrint('Done building documentation', SECTION_COLOR)

##############################################################################
#                               Build Data Files                             #
##############################################################################

def buildDataFiles(state):
    src = 'data-files'
    dst = state.installDir
    
    if os.path.exists(src):
        if verbosity >= NORMAL: colorPrint('\nCopying data files', SECTION_COLOR)
        copyIfNewer(src, dst, verbosity >= VERBOSE, verbosity == NORMAL)
        if verbosity >= VERBOSE: colorPrint('Done copying data files', SECTION_COLOR)

##############################################################################
#                               Build Include                                #
##############################################################################
""" Copies headers to the build directory. """
def buildInclude(state):
    src = 'include'
    dst = state.installDir + 'include'
    
    if os.path.exists(src):
        if verbosity >= NORMAL: colorPrint('\nCopying public header files', SECTION_COLOR)
        copyIfNewer(src, dst, verbosity >= VERBOSE, verbosity >= NORMAL)
        if verbosity >= VERBOSE: colorPrint('Done copying public header files', SECTION_COLOR)

##############################################################################
#                                 Build Clean                                #
##############################################################################

def buildClean(state):
    if verbosity >= NORMAL: colorPrint('Deleting all generated files', SECTION_COLOR)
    
    rmdir(state.rootDir + state.buildDir, verbosity >= VERBOSE)
    rmdir(state.rootDir + state.tempDir, verbosity >= VERBOSE)

    if verbosity >= VERBOSE: colorPrint('Done deleting generated files\n', SECTION_COLOR)


#########################################################################


""" Compiles the source file. """
def makeObjectFile(state, cfile, options):
    ofile = getObjectFilename(state, cfile)

    # Create the directory for the ofile as needed
    i = ofile.rfind("/")
    if (i >= 0):
        mkdir(ofile[:i], verbosity >= VERBOSE)

    args = string.split(options) 
  
    if extname(cfile).lower() == 'c':
        # At least on Darwin, g++ (vs. gcc) fails to correctly
        # identify c files with old syntax (e.g., png.c) and
        # needs an explicit language argument.
        args += ['-x', 'c']

    args += ['-o', ofile, cfile]

    if verbosity == NORMAL:
        # 'run' will not print the full command, so we just
        # print the filename to be compiled here.

        print shortname(state.rootDir, cfile)

    ret = run(state.compiler, args, verbosity >= VERBOSE)

    if ret != 0:
        sys.exit(ret)
    else:
        if verbosity >= VERBOSE: print

#########################################################################

""" Add the dependencies from the libraries list (recursively)
    libraries must be a set of canonical library names
"""
def extendLibrariesWithDependencies(libraries):
    # Start with an initial list of all libraries
    stack = [libname for libname in libraries]

    # Keep looping as long as we added something
    while len(stack) > 0:
        libname = stack.pop()
        
        if libraryTable.has_key(libname):
            for dependency in libraryTable[libname].dependsOnList:
                if not dependency in libraries:
                    # This is a new dependency, add it to both the process
                    # stack and to the set of libraries
                    libraries.add(dependency)
                    stack.append(dependency)

"""allFiles is a list of all files on which something
   depends for the project. """
def getLinkerOptions(state, allFiles):
    opt = state.linkerOptions

    opt += [('-L' + path) for path in state.libraryPaths()]

    # Set of canonically named libraries to link against
    libraries        = Set()

    # Compute a list of all libraries needed from the headers
    for path in allFiles:
        header = betterbasename(path)
        if headerToLibraryTable.has_key(header):
            libs = headerToLibraryTable[header]
            libraries.update(libs)
                
            if verbosity >= TRACE:
                if len(libs) > 1:
                   print '#include "' + header + '" triggered links to ' + libs
                elif len(libs) > 0:
                   print '#include "' + header + '" triggered a link to ' + libs[0]

    # Add the dependencies from the libraries list
    extendLibrariesWithDependencies(libraries)
    
    # Check for additional libraries that will be needed from the
    # symbols in the static libraries on which we depend.
    # TODO:

    # Since we may have just changed the list of libraries, re-extend it
    # with dependencies
    # TODO:     extendLibrariesWithDependencies(libraries)

    # Topologically sort library list to satisfy linker ordering
    libList = [libname for libname in libraries]
    if verbosity >= TRACE: print 'Libraries before sort: ', libList
    sortLibraries(libList)
    if verbosity >= TRACE: print 'Libraries after sort: ', libList

    # Separate into static libs, dynamic libs, and frameworks
    allLinks = []

    for libname in libList:
        if libraryTable.has_key(libname):
            lib = libraryTable[libname]

            if state.target == DEBUG:
                if state.os == 'osx' and lib.debugFramework != None:
                    allLinks += ['-framework',  lib.debugFramework]
                elif (lib.type != FRAMEWORK) and (lib.debugLib != None):
                    allLinks += ['-l' + rawLibraryFilename(findLibrary(lib.debugLib, lib.type, state.libraryPaths()))]
            else:
                if state.os == 'osx' and lib.releaseFramework != None:
                    allLinks += ['-framework',  lib.releaseFramework]
                elif (lib.type != FRAMEWORK) and (lib.releaseLib != None):
                    allLinks += ['-l' + rawLibraryFilename(findLibrary(lib.releaseLib, lib.type, state.libraryPaths()))]

        elif verbosity >= NORMAL:
            colorPrint("Detected use of the '" + libname + 
                      "' library, which iCompile does not know how to use.", WARNING_COLOR)

    # Add libraries on which we explicitly depend
    #suffix = ''
    #if state.target == DEBUG:
    #    suffix = 'd'

    #for u in usesProjectsList:
    #    if u.endswith('/'):
    #        u = u[:-1]
    #    libname = rawfilename(u) + suffix
    #    allLinks.append('-l' + libname)

    # If SDL is already on the link list then it automatically links X11
    # so avoid explicit link
    #if ('SDL' in allLinks) and ('X11' in allLinks):
    #    allLinks.remove('X11')

    if verbosity >= TRACE:
        print 'Library link options: ', allLinks
    
    return opt + allLinks

#########################################################################

""" Makes a static library from a list of object files and libraries."""
def makeStaticLibrary(state, objectFiles):
    if verbosity >= QUIET: colorPrint("\nCreating static library", SECTION_COLOR)

    ret = run('ar', ['cr', state.binaryDir + state.binaryName] + objectFiles, verbosity >= VERBOSE)
    if verbosity >= VERBOSE: print
    
    if (ret == 0):
        ret = run('ranlib', [state.binaryDir + state.binaryName], verbosity >= VERBOSE)


#########################################################################

""" Makes an executable from a list of object files. 
    """
def makeExecutable(state, objectFiles, linkOptions):

    # Create the command line arguments for the linker.
    # Note that the object files must come first
    options = []
    
    if (os.uname()[0] == 'Darwin'):
        filelistFileName = state.tempDir + 'filelist.txt'

        # Write the object file list
        f = open(filelistFileName, 'w')
        newline = '\n'
        f.write(string.join(objectFiles, newline) + newline)
        f.close()

        options += ['-filelist', filelistFileName]
    else:
        options += objectFiles

    options += linkOptions + ['-o', state.binaryDir + state.binaryName]

    if ('OpenGL' in options) or ('GL' in options):
        # Suppress the multiply defined symbols warning that 
        # comes from using OpenGL (which has both dynamic and static
        # versions of the same functions)
        options += ['-multiply_defined', 'suppress']
 
 	if (os.uname()[0] == 'Darwin'):
            # Linking OpenGL on Darwin creates problems because of the
	    # framework.  This option appears to work around the problem.
	    options += ['-all_load']

    if verbosity >= NORMAL: colorPrint('\nLinking', SECTION_COLOR)

    ret = run(state.compiler, options, verbosity >= VERBOSE)

    if ret != 0:
        sys.exit(ret)
    elif (state.target == RELEASE):
        # Strip debug symbols
	run('strip', [state.binaryDir + state.binaryName], verbosity >= VERBOSE)

###################################################################################

"""
Build all (out of date) projects on which the project described by state depends

Called from buildBinary.
"""
def buildDependencyProjects(state):

    # Create arguments to pass to the child icompile process
    libArgs = []
    
    # We don't need to pass verbosity because it is globally 
    # specified; FYI, ['--verbosity', str(verbosity - QUIET)]

    if state.target == DEBUG:
        libArgs.append('--debug')
    else:
        libArgs.append('-O')

    ret = 0
    for lib in state.usesProjectsList:
        ret = icompile(lib, libArgs)
        if ret != 0:
            break

    return ret

###################################################################################

""" Creates the object files and links them. """
def buildBinary(state):

    if verbosity >= NORMAL: 
        printBar()
        colorPrint('Building ' + state.binaryName, SECTION_COLOR)

    # Create the temp directory for object files
    mkdir(state.objDir, verbosity >= VERBOSE)

    if verbosity >= VERBOSE: colorPrint('Computing dependencies', SECTION_COLOR)
    (cfiles, dependencies, files, parents) = getDependencyInformation(state, verbosity)

    if verbosity >= TRACE: 
        print '\nBefore identifySiblingLibraryDependencies, state.usesProjectsList = ', state.usesProjectsList

    identifySiblingLibraryDependencies(files, parents, state)

    if verbosity >= TRACE: 
        print '\nAfter identifySiblingLibraryDependencies, state.usesProjectsList = ', state.usesProjectsList

    if verbosity >= TRACE:
        print 'Header files #included:'
        for f in files:
            print '  ' + f
        print

    if cfiles == []:
        print '\nNo C or C++ files found.'
        sys.exit(-10)

    ret = 0

    # Static libraries can have mutually recursive dependencies and don't
    # link against their dependencies anyway.  Everything else must build
    # its dependencies first
    if state.binaryType != LIB:
        ret = buildDependencyProjects(state)

    buildList = getOutOfDateFiles(state, cfiles, dependencies, files)

    copt = string.join(getCompilerOptions(state, 
        files, state.compilerWarningOptions + state.compilerVerboseOptions), ' ')

    if verbosity >= TRACE:
        print "\nBuilding out of date files\n"    

    # Build all out of date files
    if (buildList != []):
        if verbosity >= NORMAL: colorPrint('\nCompiling', SECTION_COLOR)
    
    for file in buildList:
        makeObjectFile(state, file, copt)
        relink = 1
 
    # Generate *all* object file names (even ones that
    # aren't rebuilt
    ofiles = []
    for cfile in cfiles: 
        ofiles.append(getObjectFilename(state, cfile))

    # Definitely need to link if no executable exists
    doLink = not os.path.exists(state.binaryDir + state.binaryName)
    if not doLink:
        # See if an object file is newer than the exe
        
        exeTime = getTimeStamp(state.binaryDir + state.binaryName)
        for file in ofiles:
            if getTimeStamp(file) > exeTime:
                if verbosity >= TRACE:
                    print ("Relinking because " + file + 
                           " is newer than " + state.binaryDir + state.binaryName)
                doLink = True
                break

    # Only link when necessary
    if doLink:
        if not os.path.exists(state.binaryDir):
            mkdir(state.binaryDir, verbosity >= VERBOSE)

        if ((state.binaryType == EXE) or
            (state.binaryType == DLL)):

            # Dynamic library or executable.
            lopt = getLinkerOptions(state, files)
            makeExecutable(state, ofiles, lopt)

        else:

            # Static library.
            makeStaticLibrary(state, ofiles)

    if verbosity >= VERBOSE: colorPrint('Done building ' + state.binaryName, SECTION_COLOR)
    
#########################################################################

""" Returns two lists; all of the arguments up to and including the first
"--run" or "--gdb" and all arguments to the right."""
def separateArgs(args):
    for i in xrange(0, len(args)):
        if (args[i] == "--run") or (args[i] == "--gdb"):
            progArgs = args[(i + 1):]
            args = args[:(i + 1)]
            return (args, progArgs)
    return (args, [])


#########################################################################
""" Called from runCompile to launch the program on completion.  Returns
    the program's exit code. """
def runCompiledProgram(state, progArgs):
    printBar()
    curDir = os.getcwd()
    os.chdir(state.binaryDir)
    cmd = './' + state.binaryName + ' ' + string.join(progArgs, ' ')
    ret = os.system(cmd)
    os.chdir(curDir)
    return ret


#########################################################################

""" Called from runCompile to launch the program on completion.  Returns
    the program's exit code. """
def gdbCompiledProgram(state, progArgs):
    # Write out the 'run' command to a file since gdb doesn't
    # accept it on the command line.
    commandFile = state.tempDir + 'gdb-commands.txt'
    f = open(commandFile, 'w')
    f.write('run ' + string.join(progArgs, ' '))
    f.close()

    # Options: -q   Don't print copyright info
    #          -x   Run the gdb commands we wrote out to the command file
    #          -cd  Working directory
    #          -f   Print files and line numbers in Emacs-compatible format
    cmd = ('gdb -x ' + commandFile + ' -cd ' + state.binaryDir +
                ' -q -f ' + state.binaryName)
    print cmd
    printBar()
    return os.system(cmd)


####################################################################
        
""" Choose and configure the compiler for this platform and target."""
def configureCompiler(state):
    base = rawfilename(state.compiler).lower()

    if (base == 'cl') and (os.name == 'nt'):
        configureVC(state)
    else:
        configureGpp(state)


""" Configure VC8 as our compiler of choice.
    Called from configureCompiler."""
def configureVC(state):
    userCompilerOptions = state.compilerOptions
    userLinkerOptions = state.linkerOptions

    if (state.target == RELEASE):
        state.compilerOptions = \
                ['/O2',           # Optimization
                 '/D_RELEASE']

        state.linkerOptions   = []
    else:
        state.compilerOptions =\
                ['/D_DEBUG',     
                 '/Zi']            # Debug information
        state.linkerOptions   = []


    state.compilerOptions += \
            ['/GR',                # Run-time type information
             '/EHs',               # Enable exception handling, assume that
                                   #   extern functions do not throw.
             '/nologo']            # Surpress banner

    if (state.binaryType == DLL):
        # Select the appropriate multithreaded vc library
        if state.target == RELEASE:
            state.linkerOptions  += ['/MD']
        else:
            state.linkerOptions  += ['/MDd']
    else:
        if state.target == RELEASE:
            state.linkerOptions  += ['/MT']
        else:
            state.linkerOptions  += ['/MTd']


    # 64-bit warnings and most others
    state.compilerWarningOptions = ['/Wp64', '/W2']
  
    # Put user options last so that they can override ours
    if userCompilerOptions != None: state.compilerOptions += userCompilerOptions
    if userLinkerOptions != None: state.linkerOptions += userLinkerOptions

    # Remove empty arguments (they will confuse the linker)
    while '' in state.linkerOptions:
        state.linkerOptions.remove('')
    


""" Configure g++ as our compiler of choice.
    Called from configureCompiler."""
def configureGpp(state):

    userCompilerOptions = state.compilerOptions
    userLinkerOptions = state.linkerOptions

    if (state.target == RELEASE):
        state.compilerOptions = ['-O3',
                                 '-D_RELEASE', 
                                 '-fno-trapping-math',
                                 '-fno-strict-aliasing',
                                 '-s']
        # Had to remove '-fno-math-errno' because g++ occasionally
        # crashes with that option.

        # -fno-strict-aliasing slows down the produced code but allows
        # type-punned aliasing to be safe, which is what many C++ programmers
        # need.

        # Removed '-fno-finite-math-only' because it is not supported
        # by g++3.2

        state.linkerOptions   = []
    else:
        state.compilerOptions = ['-D_DEBUG', '-g']
        state.linkerOptions   = []

    if state.os == 'linux':
        # LARGEFILE_SOURCE enables some newer interfaces for
        # fopen that work with >2GB files
        flags = shell('getconf LFS_CFLAGS', verbosity >= VERBOSE)
        state.compilerOptions += string.split(flags, ' ')

    if state.os == 'osx':
        universalBinary = False # TODO: Add universal binary support for libraries later

        # Not supported on OS X
        state.compilerOptions += ['-D__cdecl=', '-D__stdcall=']

        # needed for inline asm on OS X
        state.compilerOptions.append('-fasm-blocks')

        arch = []
        if universalBinary:
            # on an intel machine we can compile for both ppc and intel
            # but on a ppc machine we use the defaults and compile only for ppc
            if (machine() == 'i386'):
                arch = ['-arch', 'i386', '-arch', 'ppc']
        else:
            if (machine() == 'i386'):
                arch = ['-arch', 'i386']
            else:
                arch = ['-arch', 'ppc']

        state.compilerOptions += arch
        state.linkerOptions   += arch 

    # Use pipes instead of temporary files for 
    # inter-process communication; this should be faster.
    state.compilerOptions += ['-pipe']
 
    if (state.binaryType == DLL):
        state.linkerOptions  += ['-shared']

    state.compilerWarningOptions = ['-Wall', '-Wformat=2']
  
    # Put user options last so that they can override ours
    if userCompilerOptions != None: state.compilerOptions += userCompilerOptions
    if userLinkerOptions != None: state.linkerOptions += userLinkerOptions

    # Remove empty arguments (they will confuse the linker)
    while '' in state.linkerOptions:
        state.linkerOptions.remove('')


#########################################################################

""" Main program execution.
  Returns the exit code of the build process.
  args     - arguments to iCompile
  progArgs - arguments to pass on to the compiled program
"""
def main(state, args, progArgs, doGDB, doRun):
    if (verbosity >= VERBOSE):
        print state
        
    if '--clean' in args:
        buildClean(state)
        # Exit early, preventing the cache from being written
        sys.exit(0)

    if '--doc' in args:
        buildDocumentation(state)
        maybePrintBar()

    if state.binaryType == EXE:
        buildDataFiles(state)
        maybePrintBar()

    buildBinary(state)

    maybePrintBar()
        
    if isLibrary(state.binaryType):
        buildInclude(state)
        maybePrintBar()
    
    if doGDB:
        return gdbCompiledProgram(state, progArgs)

    if doRun:
        return runCompiledProgram(state, progArgs)

    if not (doGDB or doRun) and (verbosity >= NORMAL):
        if state.binaryType == EXE:
            print '\nExecutable written to ' + state.binaryDir + state.binaryName
        else:
            print '\nLibrary written to ' + state.binaryDir + state.binaryName
                
    return 0

###############################################################



########################################################################################
# The beep is controlled by the outermost configuration file
doBeep = False

# List of all projects for which iCompilation has begin; prevents recursive execution
# in the event of recursive dependencies.
alreadyiCompiled = []

"""
Runs iCompile on the specified project (which must be a directory) with the specified 
program arguments and returns its return code.
"""
def icompile(projectDir, allArgs):
    
    curdir = os.getcwd()

    os.chdir(projectDir)

    resolvedProjectDir = os.getcwd()

    if resolvedProjectDir in alreadyiCompiled:
        # We've already started compiling this project somewhere back on
        # the thread stack; abort
        os.chdir(curdir)
        return 0

    alreadyiCompiled.append(resolvedProjectDir)

    (args, progArgs) = separateArgs(allArgs)

    state = getConfigurationState(args)

    configureCompiler(state)

    doGDB   = '--gdb' in args
    doRun   = '--run' in args

    if doGDB and doRun:
        colorPrint('Cannot specify both --gdb and --run options.', WARNING_COLOR)
        sys.exit(-1)

    if (doGDB or doRun) and (state.binaryType != EXE):
        colorPrint('Cannot specify --gdb or --run for a library.', WARNING_COLOR)
        sys.exit(-1)

    # Load cached dependencies for this project
    cacheFilename = pathConcat(state.tempDir, '.icompile-cache')
    loadCache(state, cacheFilename)

    ret = main(state, args, progArgs, doGDB, doRun)

    mkdir(state.tempDir, verbosity >= VERBOSE)
    saveCache(state, cacheFilename)

    os.chdir(curdir)

    doBeep = state.beep
    return ret


#################################################################
# Entry point

if __name__ == '__main__':

    # Process global arguments and then invoke the actual build process

    (args, progArgs) = separateArgs(sys.argv[1:])

    # Set the global variables
    i = find(args, '--verbosity')
    if i > -1:
        if i < len(args) - 1:
            try:
                # Clamp verbosity to the legal levels
                verbosity = max(min(string.atoi(args[i + 1]) + QUIET, TRACE), QUIET)
            except ValueError:
                maybeWarn('WARNING: illegal --verbosity argument: ' + args[i + 1], state)
        else:
            maybeWarn('WARNING: --verbosity used without an argument', state)

    # --help and --version are processed immediately
    if ('--version' in args):
        printVersion()
        sys.exit(0)

    if ('--help' in args):
        printHelp()
        sys.exit(0)

    ret = icompile('.', sys.argv[1:])

    if (verbosity >= NORMAL) and doBeep:
        beep()

    sys.exit(ret)
