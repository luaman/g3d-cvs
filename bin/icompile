!/usr/bin/env python
# -*- python -*-
#
# See manual.html for documentation.  http://ice.sf.net
#
# Copyright 2003-2006 Morgan McGuire and Rob Hunter
# All rights reserved.
#
# morgan@cs.williams.edu, rob@cs.brown.edu
#
# DO NOT MODIFY THIS SCRIPT.  EDIT ICE.TXT AND ~/.ICOMPILE TO CUSTOMIZE
# YOUR PROJECT CONFIGURATION.

version = [0, 4, 6]

import sys, string, os, os.path, fileinput, tempfile, shutil, re
import commands, pickle, time, ConfigParser
from sets import Set
from platform import machine
from string import ljust

from icevariables import *
from icedoticompile import *
from iceutils import *
from icedoxygen import *
from icehelp import *
from icelibrary import *
import icecopyifnewer
from icecopyifnewer import copyIfNewer
from icetopsort import *

if int(sys.version[:string.find(sys.version, '.')]) < 2:
    print ('iCompile requires Python 2.0 or later.  You are running Python '
           + sys.version)
    sys.exit(-10)


# TODO: remove
staticLinkDependencies = []


def isLibrary(L):
    return L == LIB or L == DLL

#########################################################################

""" Returns true if this is a cpp source filename. """
def isCFile(file):
    ext = string.lower(extname(file))

    return ((ext == 'cpp') or
           (ext == 'c') or
           (ext == 'c++') or
           (ext == 'cxx') or
           (ext == 'i') or
           (ext == 'ii') or
	   ((os.uname()[0] == 'Darwin') and
            ((ext == 'mm') or
             (ext == 'm') or
             (ext == 'mi') or
             (ext == 'mii'))))

#########################################################################

"""
A regular expression matching files that should be excluded from compilation
Set by processProjectFile.
"""
excludeFromCompilation = None

def listCFilesVisitor(result, dirname, files):
    dir = dirname

    # Strip any unnecessary "./"
    if (dirname[:2] == "./"):
        dir = dir[2:]

    if (excludeFromCompilation.search(dir) != None):
        # Don't recurse into subdirectories of excluded directories
        del files[:]
        return

    # We can't modify files while iterating through it, so
    # we must make a list of all files that are to be removed before the
    # next iteration of the visitor.   
    removelist = [];
    for f in files:
         if (excludeFromCompilation.search(f) != None):
            if verbosity >= VERBOSE: print "  Ignoring '" + f + "'"
            removelist.append(f)
            
         elif isCFile(f):
             
            # Ensure the path ends in a slash (when needed)
            filename = pathConcat(dir, f)

            if (excludeFromCompilation.search(filename) == None):
                result.append(filename)

    # Remove any subdir in files that is itself excluded to prevent
    # later recursion into it.
    for f in removelist:
        files.remove(f)


"""Returns all files with gcc-recognized c/c++ endings for the given directory
   and all subdirectories.
   
   Filenames must be relative to the "rootDir" directory.  dir will be
   a subdirectory of rootDir."""
def listCFiles(dir = ''):
    if (dir == ''): dir = './'

    result = []

    os.path.walk(dir, listCFilesVisitor, result)
    return result


""" Non-recursive version of listCFiles. (not actually used) """
def flatListCFiles(dir = ''):
    if (dir == ''): dir = './'

    all = os.listdir(dir)
    cfiles = []
    for f in all:
        if isCFile(f): cfiles.append(dir + f)

    return cfiles
   
##############################################################################
#                            Cache Management                                #
##############################################################################

""" Loads the icompile cache that preserves values between calls """
def loadCache(filename):
    global state

    if verbosity >= TRACE: print "Loading cache from " + filename + "\n"

    if os.path.exists(filename):
        file = open(filename, 'r')
        try:
            state.cache = pickle.load(file);
        except:
            # The cache was corrupted; ignore it
            state.cache = {}
            if verbosity >= NORMAL: 
                print "Internal iCompile cache at '" + filename + "' corrupted."

        if verbosity >= TRACE: print "cache = ", state.cache


        file.close()
    else:
        state.cache = {}

##############################################################################

def saveCache(filename):
    file = open(filename, 'w')
    pickle.dump(state.cache, file)
    file.close()

##############################################################################
#                            Discover Platform                               #
##############################################################################

def discoverPlatform():
    global state

    state.os = ''
    compiler = ''

    # Figure out the os
    if (os.uname()[0] == 'Linux'):
        state.os = 'linux'
    elif (os.uname()[0] == 'FreeBSD'):
        state.os = 'freebsd'
    elif (os.uname()[0] == 'Darwin'):
        state.os = 'osx'
    else:
        raise 'Error', 'iCompile only supports Linux and OS X'

    # Figure out the compiler
    c = compilerName()
    compiler = betterbasename(c)

    if beginswith(compiler, 'g++') or beginswith(compiler, 'gcc'):
        compiler = 'g++'

    # Append the major and minor compiler version number to the compiler name
    v = getVersion(c)    
    if len(v) > 2:
        v = v[0:2]
    if len(v) < 2:
        # Version number was short; add a 0 minor number
        v = v + 0
    compiler += string.join(map(str, v), '.')

    state.platform = state.os + '-' + machine() + '-' + compiler
    
##############################################################################
#                            Build Documentation                             #
##############################################################################

def buildDocumentation():
    maybeColorPrint('Building documentation', SECTION_COLOR)

    # See if there is a Doxygen file already
    if not os.path.exists(rootDir + "Doxyfile"):
        print ("Your project does not have a 'Doxyfile' file, so iCompile " +
               "will now create one for you.\n")
        createDoxyfile()
        print "Done creating 'Doxyfile'\n\n"

    run("doxygen", ["Doxyfile"])

    if (os.path.exists(rootDir + 'doc-files')):
        copyIfNewer(rootDir + 'doc-files', 
                    rootDir + BUILDDIR + '/doc', 
                    verbosity >= VERBOSE)

    maybeColorPrint('Done building documentation', SECTION_COLOR)

##############################################################################
#                               Build Data Files                             #
##############################################################################

def buildDataFiles():
    src = 'data-files'
    dst = BUILDDIR + '/' + DISTRIBDIR
    
    if os.path.exists(src):
        if verbosity >= NORMAL: colorPrint('Copying data files', SECTION_COLOR)
        copyIfNewer(src, dst, verbosity >= VERBOSE, verbosity == NORMAL)
        if verbosity >= VERBOSE: colorPrint('Done copying data files', SECTION_COLOR)

##############################################################################
#                               Build Include                                #
##############################################################################
""" Copies headers to the build directory. """
def buildInclude():
    src = 'include'
    dst = BUILDDIR + '/' + DISTRIBDIR + '/include'
    
    if os.path.exists(src):
        if verbosity >= NORMAL: colorPrint('Copying public header files', SECTION_COLOR)
        copyIfNewer(src, dst, verbosity >= VERBOSE, verbosity >= NORMAL)
        if verbosity >= VERBOSE: colorPrint('Done copying public header files', SECTION_COLOR)

##############################################################################
#                                 Build Clean                                #
##############################################################################

def buildClean():
    if verbosity >= NORMAL: colorPrint('Deleting all generated files', SECTION_COLOR)
    
    rmdir(rootDir + BUILDDIR, verbosity >= VERBOSE)
    rmdir(rootDir + tempDir, verbosity >= VERBOSE)

    if verbosity >= VERBOSE: colorPrint('Done deleting generated files\n', SECTION_COLOR)


#########################################################################

"""Returns a list of *all* files on which this file depends (including
   itself).  Returned filenames must either be fully qualified or
   relative to the "rootDir" dir.

   May modify the default compiler and linker options
   """
def getDependencies(file, iteration = 1):
    # We need to use the -msse2 flad during dependency checking because of the way
    # xmmintrin.h is set up
    #
    # -MG means "don't give errors for header files that don't exist"
    # -MM means "don't tell me about system header files"
    raw = shell(compilerName() + ' -M -msse2 -MG ' +
                string.join(getCompilerOptions([]), ' ') + ' ' + file,
                verbosity >= VERBOSE)

    if verbosity >= TRACE:
        print raw

    if beginswith(raw, 'In file included from'):
        # If there was an error, the output will have the form
        # "In file included from _____:" and a list of files
        
        if iteration == 3:
            # Give up; we can't resolve the problem
            print raw
            sys.exit(-1)
        
        if verbosity >= VERBOSE:
            print ('\nThere were some errors computing dependencies.  ' +
                   'Attempting to recover.('), iteration,')'
        
        # Generate a list of files and see if they are something we
        # know how to fix.
        noSuchFile = []
        for line in string.split(raw, '\n'):
            if line.endswith(': No such file or directory'):
                x = line[:-len(': No such file or directory')]
                j = x.rfind(': ')
                if (j >= 0): x = x[(j+2):]

                # x now has the filename
                noSuchFile.append(betterbasename(x))

        if verbosity >= NORMAL: print 'Files not found:', noSuchFile
        
        # Look for files we know how to handle
        for f in noSuchFile:
            if f == 'wx.h':
                if verbosity >= NORMAL: print 'wxWindows detected.'
                defaultCompilerOptions.append(shell('wx-config --cxxflags', verbosity >= VERBOSE))
                defaultLinkerOptions.append(shell('wx-config --gl-libs --libs', verbosity >= VERBOSE))
                
            if includeTable.has_key(f):
                if verbosity >= NORMAL: print f,'detected.'
                includePaths += includeTable[file]

        return getDependencies(file, iteration + 1)

    else:

        # Normal case, no error
        if 'implemented' in raw: print raw
        result = []
        raw = raw.replace('\\', ' ')
        for line in raw.splitlines():
            # gcc 3.4.2 likes to print the name of the file first, as in
            # """# 1 "/home/faculty/morgan/Projects/ice/tests/meta/helper.lib//""""
            if not beginswith(line, '# '):
                result += string.split(line, ' ')

        # There is always at least one file since everything depends on itself.
        
        # The first element of result will be "file:", so strip it
        files = result[1:]
        result = []

        # Add the './' to raw files
        for f in files:
            f = f.strip()
            if '/' in f:
                result.append(f)
            elif f == '':
                # empty filename
                files.remove(f)
            else:
                result.append('./' + f)

        return result


#########################################################################

"""Finds all of the C++/C files in rootDir and returns
 dependency information for them as the tuple
 [dependencies, allDependencyFiles] 
 where dependencies[f] is the list of all files on which
 f depends and allDependencyFiles is the list of all files
 on which any file depends.

 While getting dependencies, this may change the include/library
 list and restart the process if it appears that some include
 directory is missing.
"""
def getDependencyInformation():
    
    # Hash table mapping C files to the list of all files
    # on which they depend.
    dependencies = {}

    # All files on which something depends
    dependencySet = Set()

    # Find all the c files
    allCFiles = listCFiles(rootDir)

    if verbosity >= TRACE: print 'Source files found:', allCFiles

    # Get their dependencies
    for cfile in allCFiles:

        # Get the compiler options that will be needed for them.
        # Do not use warning or verbose options for this; they
        # would corrupt the output.
        dlist = getDependencies(cfile)

        # Update the dependency set
        for d in dlist: dependencySet.add(d)
 
        dependencies[cfile] = dlist
    
    # List of all files on which some other file depends
    dependencyFiles = [d for d in dependencySet]

    return (allCFiles, dependencies, dependencyFiles)

#########################################################################

"""Given a source file (relative to rootDir) returns an object file
  (relative to rootDir).
"""
def getObjectFilename(sourceFile):
    # strip the extension and replace it with .o
    i = string.rfind(sourceFile, '.')
    return state.objDir + sourceFile[len(rootDir):i] + '.o'

#########################################################################

def getOutOfDateFiles(cfiles, dependencies, files):
    # Get modification times for all of the files
    timeStamp = {}
    for file in files:
        timeStamp[file] = getTimeStamp(file)
    
    buildList = []
    
    # Need to rebuild all if this script was modified more
    # recently than a given file.
    icompileTime = getTimeStamp(sys.argv[0])

    # Rebuild all if ice.txt or .icompile was modified
    # more recently.
    if os.path.exists('ice.txt'):
        iceTime = getTimeStamp('ice.txt')
        if iceTime > icompileTime:
            icompileTime = iceTime

    HOME = os.environ['HOME']
    preferenceFile = pathConcat(HOME, '.icompile')
    if os.path.exists(preferenceFile):
        configTime = getTimeStamp(preferenceFile)
        if configTime > icompileTime:
            icompileTime = configTime


    # Generate a list of all files newer than their targets
    for cfile in cfiles:
        ofile = getObjectFilename(cfile)
        otime = getTimeStamp(ofile)
        rebuild = (otime < icompileTime)

        if rebuild and verbosity >= TRACE:
            print "iCompile is newer than " + ofile

        if not rebuild:
            # Check dependencies
            for d in dependencies[cfile]:
                dtime = timeStamp[d]
                if otime < dtime:
                    if verbosity >= TRACE:
                        print d + " is newer than " + ofile
                    rebuild = 1
                    break

        if rebuild:
            # This file needs to be rebuilt
            buildList.append(cfile)

    return buildList

#########################################################################

# Table mapping headers to lists of directories that should be -I when
# that header appears.
includeTable = {
    'SDL.h'      : ['/usr/include/SDL']
    }

"""allFiles is a list of all files on which something
   depends for the project.

   Returns a list of strings

   extraOpts are options that are needed for compilation
   but not dependency checking:
     compilerWarningOptions + compilerVerboseOptions
   """
def getCompilerOptions(allFiles, extraOpts = []):
    opt = configCompilerOptions() + extraOpts + ['-c']
    
    for i in includePaths():
        opt += ['-I' + i]

    # See if the xmm intrinsics are being used
    # This was disabled because -msse2 allows code generation,
    # not just explicit use of intrinsics
    #for f in allFiles:
    #    if f[-11:] == 'xmmintrin.h':
    #        opt += ['-msse2']
    #        break
        
    return opt

""" Compiles the source file. """
def makeObjectFile(cfile, options):
    ofile = getObjectFilename(cfile)
   
    # Create the directory for the ofile as needed
    i = ofile.rfind("/")
    if (i >= 0):
        mkdir(ofile[:i], verbosity >= VERBOSE)

    args = string.split(options) 
  
    if (extname(cfile).lower() == 'c'):
        # At least on Darwin, g++ (vs. gcc) fails to correctly
        # identify c files with old syntax (e.g., png.c) and
        # needs an explicit language argument.
        args += ['-x', 'c']

    args += ['-o', ofile, cfile]

    if verbosity == NORMAL:
        # 'run' will not print the full command, so we just
        # print filename to be compiled here.

        if beginswith(cfile, rootDir):
            # Don't bother printing the root directory name
            # when it appears
            print cfile[len(rootDir):]
        else:
            print cfile

    ret = run(compilerName(), args, verbosity > NORMAL)

    if ret != 0:
        sys.exit(ret)
    else:
        if verbosity >= VERBOSE: print

#########################################################################

# allfiles is a list of all files on which something depends.  May be empty list.
# 
def printVariables(icompileargs, progargs, allfiles = []):
    print "platform               = '" + state.platform + "'"
    print "rootDir                = '" + rootDir + "'"
    print "projectName            = '" + state.projectName + "'"
    print "target                 = " + state.target
    print "binaryType             = " + state.binaryType
    print "binaryDir              = '" + state.binaryDir + "'"
    print "binaryName             = '" + state.binaryName + "'"
    print "objDir                 = '" + state.objDir + "'"
    print "iCompile args          =", icompileargs
    print "quiet                  =", quiet
    print "--run args             =", progargs
    print "compilerName           = '" + compilerName() + "'"
    print "compilerOptions        =", getCompilerOptions(allfiles,
                                         compilerWarningOptions +
                                         compilerVerboseOptions)
    print "compilerWarningOptions =", compilerWarningOptions
    print "compilerVerboseOptions =", compilerVerboseOptions
    print "linkerOptions          =", linkerOptions()
    print "defaultCompilerOptions =", defaultCompilerOptions
    print "defaultLinkerOptions   =", defaultLinkerOptions
    print "includePaths           =", includePaths()
    print "libraryPaths           =", libraryPaths()
    print "$HOME                  =", os.environ['HOME']
    print "cwd                    =", os.getcwd()
    print "exclude                =", configGet(config, 'GLOBAL', 'exclude', False)
    print "usesList               =", configGet(config, 'GLOBAL', 'uses')

"""Mutates dynamicLinkFiles to contain additional libraries that are probably
needed by the staticLinkFiles.  Called from getLinkerOptions.
"""
def getAdditionalDynamicLinks(dynamicLinkFiles, staticLinkFiles):
    if verbosity >= TRACE: print '\nBegin getAdditionalDynamicLinks'
    
    # Static files may have their own dependencies.  We track these down by
    # looking at symbols defined in the library and seeing which ones map
    # to common dynamic libraries.
    for file in staticLinkFiles:
        sfile = findLibrary(file, STATIC, libraryPaths())
        if os.path.exists(sfile):
            cmd = 'nm --extern-only --demangle --undefined-only ' + sfile
            if verbosity >= VERBOSE: colorPrint(cmd, COMMAND_COLOR)

            symbols = string.split(commands.getoutput(cmd))

            for symbol in symbols:
                if extraLink.has_key(symbol):
                    (debug, release) = extraLink[symbol]

                    if state.target == DEBUG:
                        lfile = debug
                    else:
                        lfile = release
             
                    if verbosity >= TRACE:
                        print (symbol + " in " + sfile +
                              " triggered dynamic link against " + lfile)

                    if not (lfile in dynamicLinkFiles):
                        dynamicLinkFiles.append(lfile)

    if verbosity >= TRACE: print 'End getAdditionalDynamicLinks\n'


""" Add the dependencies from the libraries list (recursively)
    libraries must be a set of canonical library names
"""
def extendLibrariesWithDependencies(libraries):
    # Start with an initial list of all libraries
    stack = [libname for libname in libraries]

    # Keep looping as long as we added something
    while len(stack) > 0:
        libname = stack.pop()
        
        if libraryTable.has_key(libname):
            for dependency in libraryTable[libname].dependsOnList:
                if not dependency in libraries:
                    # This is a new dependency, add it to both the process
                    # stack and to the set of libraries
                    libraries.add(dependency)
                    stack.append(dependency)

"""allFiles is a list of all files on which something
   depends for the project. """
def getLinkerOptions(allFiles):

    opt = linkerOptions()
    opt += [('-L' + path) for path in libraryPaths()]


    # Set of canonically named libraries to link against
    libraries        = Set()

    # Compute a list of all libraries needed from the headers
    for path in allFiles:
        header = betterbasename(path)
    
        if headerToLibraryTable.has_key(header):
            libs = headerToLibraryTable[header]
            libraries.update(libs)
                
            if verbosity >= TRACE:
                if len(libs) > 1:
                   print '#include "' + header + '" triggered links to ' + libs
                elif len(libs) > 0:
                   print '#include "' + header + '" triggered a link to ' + libs[0]

    # Add the dependencies from the libraries list
    extendLibrariesWithDependencies(libraries)
    
    # Check for additional libraries that will be needed from the
    # symbols in the static libraries on which we depend.
    # TODO:

    # Since we may have just changed the list of libraries, re-extend it
    # with dependencies
    # TODO:     extendLibrariesWithDependencies(libraries)

    # Topologically sort library list to satisfy linker ordering
    libList = [libname for libname in libraries]
    if verbosity >= TRACE: print 'Libraries before sort: ', libList
    sortLibraries(libList)
    if verbosity >= TRACE: print 'Libraries after sort: ', libList

    # Separate into static libs, dynamic libs, and frameworks
    allLinks = []

    for libname in libList:
        if libraryTable.has_key(libname):
            lib = libraryTable[libname]

            if state.target == DEBUG:
                if state.os == 'osx' and lib.debugFramework != None:
                    allLinks += ['-framework',  lib.debugFramework]
                elif (lib.type != FRAMEWORK) and (lib.debugLib != None):
                    allLinks += ['-l' + rawLibraryFilename(findLibrary(lib.debugLib, lib.type, libraryPaths()))]
            else:
                if state.os == 'osx' and lib.releaseFramework != None:
                    allLinks += ['-framework',  lib.releaseFramework]
                elif (lib.type != FRAMEWORK) and (lib.releaseLib != None):
                    allLinks += ['-l' + rawLibraryFilename(findLibrary(lib.releaseLib, lib.type, libraryPaths()))]

        elif verbosity >= NORMAL:
            colorPrint("Detected use of the '" + libname + 
                      "' library, which iCompile does not know how to use.", WARNING_COLOR)

    # Add libraries on which we explicitly depend
    #suffix = ''
    #if state.target == DEBUG:
    #    suffix = 'd'

    #for u in usesProjectsList:
    #    if u.endswith('/'):
    #        u = u[:-1]
    #    libname = rawfilename(u) + suffix
    #    allLinks.append('-l' + libname)

    # TODO: Add links specified in the config file
    #extraStaticLibs = string.split(configGet(config, state.target, 'staticlibs'), ':')
    #allLinks += [('-l' + lib) for lib in extraStaticLibs]

    # If SDL is already on the link list then it automatically links X11
    # so avoid explicit link
    #if ('SDL' in allLinks) and ('X11' in allLinks):
    #    allLinks.remove('X11')

    if verbosity >= TRACE:
        print 'Library link options: ', allLinks
    
    return opt + allLinks

#########################################################################

""" Makes a static library from a list of object files and libraries."""
def makeStaticLibrary(objectFiles):
    if verbosity >= QUIET: colorPrint("Creating static library", SECTION_COLOR)

    ret = run('ar', ['cr', state.binaryDir + state.binaryName] + objectFiles, verbosity >= VERBOSE)
    if verbosity >= VERBOSE: print
    
    if (ret == 0):
        ret = run('ranlib', [state.binaryDir + state.binaryName], verbosity >= VERBOSE)


#########################################################################

""" Makes an executable from a list of object files. 
    """
def makeExecutable(objectFiles, linkOptions):

    # Create the command line arguments for the linker.
    # Note that the object files must come first
    options = []
    
    if (os.uname()[0] == 'Darwin'):
        filelistFileName = tempDir + 'filelist.txt'

        # Write the object file list
        f = open(filelistFileName, 'w')
        newline = '\n'
        f.write(string.join(objectFiles, newline) + newline)
        f.close()

        options += ['-filelist', filelistFileName]
    else:
        options += objectFiles

    options += linkOptions + ['-o', state.binaryDir + state.binaryName]

    if ('OpenGL' in options) or ('GL' in options):
        # Suppress the multiply defined symbols warning that 
        # comes from using OpenGL (which has both dynamic and static
        # versions of the same functions)
        options += ['-multiply_defined', 'suppress']
 
 	if (os.uname()[0] == 'Darwin'):
            # Linking OpenGL on Darwin creates problems because of the
	    # framework.  This option appears to work around the problem.
	    options += ['-all_load']

    if verbosity >= NORMAL: colorPrint('\nLinking', SECTION_COLOR)

    ret = run(compilerName(), options, verbosity >= VERBOSE)

    if ret != 0:
        sys.exit(ret)
    elif (state.target == RELEASE):
        # Strip debug symbols
	run('strip', [state.binaryDir + state.binaryName], verbosity >= VERBOSE)

#########################################################################

""" Returns sibling directories that are also iCompile libraries as names
    relative to the current directory.
    Allowed to recurse back two parent directories"""
def getLibrarySiblingDirs(howFarBack = 1):
    libsibs = []
    for dir in getSiblingDirs(howFarBack):

        # See if it contains an ice.txt and ends in a library extension
        ext = extname(dir).lower()
        if (os.path.exists(dir + '/ice.txt') and 
           ((ext == 'lib') or (ext == 'a') or 
            (ext == 'so') or  (ext == 'dll'))):
            libsibs.append(dir)

    return libsibs



""" Creates the object files and links them. """
def buildBinary():
    global usesProjectsList, usesLibrariesList

    if verbosity >= NORMAL: colorPrint('Building ' + state.binaryName, SECTION_COLOR)

    # Create the temp directory for object files
    mkdir(state.objDir, verbosity >= VERBOSE)

    if verbosity >= VERBOSE: colorPrint('Computing dependencies', SECTION_COLOR)
    (cfiles, dependencies, files) = getDependencyInformation()

    # See if any of the header files are not found; that might imply
    # sibling project is an implicit dependency.
    # Include the empty path on this list so that we'll find files
    # that are fully qualified as well as files in the current directory.
    # This list will be extended as we go forward.
    incPaths = [''] + includePaths()
    librarySiblingDirs = getLibrarySiblingDirs(3)

    for header in files:
        found = False
        i = 0
        while not found and (i < len(incPaths)):
            found = os.path.exists(pathConcat(incPaths[i], header))
            i += 1

        if not found:
            # This header doesn't exist in any of the standard include locations.
            # See if it is in a sibling directory that is a library.
            i = 0
            while not found and (i < len(librarySiblingDirs)):
                dirname = librarySiblingDirs[i]
                found = os.path.exists(dirname + '/include/' + header)
                if found:
                    if verbosity >= TRACE: 
                        print "Found '" + header + "' in '" + dirname + "/include'."
                    # We have identified a sibling library on which this project appears
                    # to depend.  

                    type = EXE
                    libname = rawfilename(dirname)
                    ext = extname(dirname).lower()
                    if ext == 'dll' or ext == 'so':
                        type = DLL
                    elif ext == 'lib' or ext == 'a':
                        type = LIB

                    if isLibrary(type):
                        if not libraryTable.has_key(libname):
                           defineLibrary(Library(libname, type, libname, libname + 'd',  
	                                         None,  None, [betterbasename(header)], [], []))

                        if not libname in usesLibrariesList:
                            usesLibrariesList.append(libname)

                        if not dirname in usesProjectsList:
                            print "Detected dependency on " + dirname + ' from #include "' + header + '".'
                            usesProjectsList.append(dirname)
                            incPaths.append(dirname + '/include/')
                            # TODO: recursively add all dependencies that come from this new header/library
                i += 1

        if not found:
            maybeWarn("Header file not found: '" + header + "'.")


    if verbosity >= TRACE:
        print 'Header files #included:'
        for f in files:
            print '  ' + f
        print

    if cfiles == []:
        print
        print "No C or C++ files found."
        sys.exit(-10)

    # Build all projects on which we depend
    #for lib in usesProjectsList:
    # TODO

    buildList = getOutOfDateFiles(cfiles, dependencies, files)

    copt = string.join(getCompilerOptions(files, compilerWarningOptions + compilerVerboseOptions), ' ')

    if verbosity >= TRACE:
        print "\nBuilding out of date files\n"    

    # Build all out of date files
    if (buildList != []):
        if verbosity >= NORMAL: colorPrint('\nCompiling', SECTION_COLOR)
    
    for file in buildList:
        makeObjectFile(file, copt)
        relink = 1
 
    # Generate *all* object file names (even ones that
    # aren't rebuilt
    ofiles = []
    for cfile in cfiles: 
        ofiles.append(getObjectFilename(cfile))

    # Definitely need to link if no executable exists
    doLink = not os.path.exists(state.binaryDir + state.binaryName)
    if not doLink:
        # See if an object file is newer than the exe
        
        exeTime = getTimeStamp(state.binaryDir + state.binaryName)
        for file in ofiles:
            if getTimeStamp(file) > exeTime:
                if verbosity >= TRACE:
                    print ("Relinking because " + file + 
                           " is newer than " + state.binaryDir + state.binaryName)
                doLink = True
                break

    # Only link when necessary
    if doLink:
        if not os.path.exists(state.binaryDir):
            mkdir(state.binaryDir, verbosity >= VERBOSE)

        if ((state.binaryType == EXE) or
            (state.binaryType == DLL)):

            # Dynamic library or executable.
            lopt = getLinkerOptions(files)
            makeExecutable(ofiles, lopt)

        else:

            # Static library.
            makeStaticLibrary(ofiles)

        print

    if verbosity >= VERBOSE: colorPrint('Done building ' + state.binaryName, SECTION_COLOR)
    
#########################################################################
""" Turns a string with paths separated by ; (or : on Linux) into
    a list of paths each ending in /."""
def makePathList(paths):
    if (os.name == 'posix'):
        # Allow ':' as a separator between paths
        paths = paths.replace(':', ';')
        
    return cleanPathList(paths.split(';'))


""" Ensures that every string in a list ends with a trailing slash,
    is non-empty, and appears exactly once."""
def cleanPathList(paths):
    out = {}

    for path in paths:
        if path == "":
            # do nothing
            0
        elif path[-1] == "/":
            out[path] = 1
        else:
            out[path + "/"] = 1

    return out.keys()

#########################################################################

""" Returns two lists; all of the arguments up to and including the first
"--run" or "--gdb" and all arguments to the right."""
def separateArgs(args):
    for i in xrange(0, len(args)):
        if (args[i] == "--run") or (args[i] == "--gdb"):
            progArgs = args[(i + 1):]
            args = args[:(i + 1)]
            return (args, progArgs)
    return (args, [])


#########################################################################
""" Called from runCompile to launch the program on completion.  Returns
    the program's exit code. """
def runCompiledProgram(progArgs):
    printBar()
    curDir = os.getcwd()
    os.chdir(state.binaryDir)
    cmd = './' + state.binaryName + ' ' + string.join(progArgs, ' ')
    ret = os.system(cmd)
    os.chdir(curDir)
    return ret


#########################################################################

""" Called from runCompile to launch the program on completion.  Returns
    the program's exit code. """
def gdbCompiledProgram(progArgs):
    # Write out the 'run' command to a file since gdb doesn't
    # accept it on the command line.
    commandFile = tempDir + 'gdb-commands.txt'
    f = open(commandFile, 'w')
    f.write('run ' + string.join(progArgs, ' '))
    f.close()

    # Options: -q   Don't print copyright info
    #          -x   Run the gdb commands we wrote out to the command file
    #          -cd  Working directory
    #          -f   Print files and line numbers in Emacs-compatible format
    cmd = ('gdb -x ../../' + commandFile + ' -cd ' + state.binaryDir +
                ' -q -f ' + state.binaryName)
    print cmd
    printBar()
    return os.system(cmd)

##########################################################################

""" Checks for ice.txt and, if not found, prompts the user to create it
    and returns if they press Y, otherwise exits."""
def checkForProjectFile(args):
    # Assume default project file
    projectFile = 'ice.txt'
    if os.path.exists(projectFile): return

    # Everything below here executes only when there is no project file

    if ('--clean' in args) and not os.path.exists(BUILDDIR):
        print
        colorPrint('Nothing to clean (you have never run iCompile in ' +
                   os.getcwd() + ')', WARNING_COLOR)
        print
        # Doesn't matter, there's nothing to delete anyway, so just exit
        sys.exit(0)

    print
    inHomeDir = (os.path.realpath(os.getenv('HOME')) == os.getcwd())

    if inHomeDir:
        colorPrint(' ******************************************************',
                   WARNING_COLOR)
        colorPrint(' * You are about run iCompile in your home directory! *',
                   'bold red')
        colorPrint(' ******************************************************',
                   WARNING_COLOR)
    else:        
        colorPrint('You have never run iCompile in this directory before.',
                   WARNING_COLOR)
    print
    print '  Current Directory: ' + os.getcwd()
    
    cfiles = flatListCFiles()
    num = len(cfiles)
    sl = shortlist(cfiles)
    
    if (num > 1):
        print '  Contains', num, 'C++ files (' + sl + ')'
    elif (num > 0):
        print '  Contains 1 C++ file (' + cfiles[0] + ')'
    else:
        print '  Contains no C++ files'    

    # Don't show dot-files first if we can avoid it
    dirs = listDirs()
    dirs.reverse()
    num = len(dirs)
    sl = shortlist(dirs)
    
    if (num > 1):
        print '  Contains', num, 'directories (' + sl + ')'
    elif (num > 0):
        print '  Contains 1 directory (' + dirs[0] + ')'
    else:
        print '  Contains no subdirectories'

    print
    
    dir = string.split(os.getcwd(), '/')[-1]
    if inHomeDir:
        prompt = ('Are you sure you want to run iCompile '+
                  'in your home directory? (Y/N)')
    else:
        prompt = ("Are you sure you want to compile the '" +
                  dir + "' project? (Y/N)")
        
    colorPrint(prompt, 'bold')
    if string.lower(getch()) != 'y':
        sys.exit(0)
        
    f = file(projectFile, 'wt')
    f.write(defaultProjectFileContents)
    f.close()
    

##########################################################################
#                             Set Variables                              #
##########################################################################
"""
 Configures the global parameters

 @param args All arguments before --run
"""
def setVariables(args):
    global state

    discoverPlatform()

    unix = True

    # On unix systems we prefix library names with 'lib'
    prefix = ''
    if unix and isLibrary(state.binaryType):
        prefix = 'lib'

    # Binary name
    if (state.binaryType == EXE):
        state.binaryDir  = BUILDDIR + '/' + DISTRIBDIR + '/'
        state.binaryName = state.projectName + d
    elif (state.binaryType == DLL):
        state.binaryDir  = BUILDDIR + '/' + DISTRIBDIR + '/' + state.platform + '-lib/'
        state.binaryName = prefix + state.projectName + d + '.so'
    elif (state.binaryType == LIB):
        state.binaryDir  = BUILDDIR + '/' + DISTRIBDIR + '/' + state.platform + '-lib/'
        state.binaryName = prefix + state.projectName + d + '.a'

    # Make separate directories for object files based on
    # debug/release
    state.objDir = tempDir + state.platform + '/' + state.target + '/'


#################################################################
        
""" Choose and configure the compiler for this platform and target."""
def configureCompiler():
    configureGpp()


""" Configure g++ as our compiler of choice.
    Called from configureCompiler."""
def configureGpp():
    global defaultCompilerOptions, compilerWarningOptions
    global compilerVerboseOptions, defaultLinkerOptions


    if (state.target == RELEASE):
        defaultCompilerOptions = ['-O3',
                                  '-D_RELEASE', 
                                  '-fno-trapping-math',
                                  '-s']
        # Had to remove "-fno-math-errno" because g++ occasionally
        # crashes with that option.

        # Removed '-fno-finite-math-only' because it is not used
        # by g++3.2

        defaultLinkerOptions   = []
    else:
        defaultCompilerOptions = ['-D_DEBUG', '-g']
        defaultLinkerOptions   = []

    # LARGEFILE_SOURCE enables some newer interfaces for
    # fopen that work with >2GB files
    defaultcompilerOptions += ['-D_LARGEFILE_SOURCE=1']

    if (os.uname()[0] == 'Darwin'):
        universalBinary = False # TODO: Add universal binary support for libraries later

        # Not supported on OS X
        defaultCompilerOptions += ['-D__cdecl=', '-D__stdcall=']

        # needed for inline asm on OS X
        defaultCompilerOptions.append('-fasm-blocks')

        arch = []
        if universalBinary:
            # on an intel machine we can compile for both ppc and intel
            # but on a ppc machine we use the defaults and compile only for ppc
            if (machine() == 'i386'):
                arch = ['-arch', 'i386', '-arch', 'ppc']
        else:
            if (machine() == 'i386'):
                arch = ['-arch', 'i386']
            else:
                arch = ['-arch', 'ppc']

        defaultCompilerOptions += arch
        defaultLinkerOptions   += arch 


    # Use pipes instead of temporary files for 
    # inter-process communication; this should be faster.
    defaultCompilerOptions += ['-pipe']
 
    if (state.binaryType == DLL):
        defaultLinkerOptions  += ['-shared']

    compilerWarningOptions     = ['-Wall', '-Wformat=2']


#################################################################
#                 Configuration & Project File                  #
#################################################################

config = ConfigParser.SafeConfigParser()

""" Reads [section]name from the provided configuration, replaces
    <> and $() values with the appropriate settings.

    If exp is False $() variables are *not* expanded. """
    
def configGet(config, section, name, exp = True):
    val = config.get(section, name)

    # Replace special values
    if '<' in val:
        if '<NEWESTGCC>' in val:
            (gppname, ver) = newestCompiler()
            val = val.replace('<NEWESTGCC>',   gppname)

        val = val.replace('<COMPILEOPTIONS>',  string.join(defaultCompilerOptions, ' '))
        val = val.replace('<LINKOPTIONS>',     string.join(defaultLinkerOptions, ' '))
        val = val.replace('<DYNAMICLIBS>',     string.join(defaultDynamicLibs, ';'))
        val = val.replace('<STATICLIBS>',      string.join(defaultStaticLibs, ';'))
        val = val.replace('<EXCLUDE>',         string.join(icecopyifnewer._cppExcludePatterns + ['^CMakeFiles$'], '|'))

    if exp:
        val = expandvars(val)

    return val

""" Called from processProjectFile """ 
def processDotICompile():
    # Set the defaults from the default .compile

    default = tempDir + 'default-.icompile'
    if not os.path.exists(default):
        mkdir(tempDir, verbosity >= VERBOSE)
        f = file(default, 'wt')
        f.write(defaultDotICompile)
        f.close()
    config.read(default)

    # Process .icompile
    HOME = os.environ['HOME']
    preferenceFile = pathConcat(HOME, '.icompile')
    if os.path.exists(preferenceFile):
        if verbosity >= TRACE:
            print 'Processing ' + preferenceFile
        config.read(preferenceFile)
    else:
        success = False

        # Try to generate a default .icompile
        if os.path.exists(HOME):
            f = file(preferenceFile, 'wt')
            if f != None:
                f.write(defaultDotICompile)
                f.close()
                success = True
                if verbosity >= TRACE:
                    colorPrint('Created a default preference file for ' +
                                    'you in ' + preferenceFile + '\n',
                                    SECTION_COLOR)
                
        # We don't need to read this new .icompile because
        # it matches the default, which we already read.
                           
        if not success and verbosity >= TRACE:
            print ('No ' + preferenceFile +
                   ' found and cannot write to '+ HOME)


""" Process the project file and .icompile so that we can use configGet.
    Sets a handful of variables."""
def processProjectFile(args):
    global config, excludeFromCompilation, quiet, usesProjectsList, usesLibrariesList

    processDotICompile()

    # Process the project file
    projectFile = 'ice.txt'
    if verbosity >= TRACE:
        print 'Processing ' + projectFile
    config.read(projectFile)

    # Don't expand '$' envvar in regular expressions since
    # $ means end of pattern.
    exclude = configGet(config, 'GLOBAL', 'exclude', False)
    excludeFromCompilation = re.compile(exclude)
 
    # Parses the "uses" line, if it exists
    L = ''
    try:
        L = configGet(config, 'GLOBAL', 'uses')
    except ConfigParser.NoOptionError:
        # Old files have no 'uses' section
        pass

    for u in string.split(L, ':'):
        if u.strip() != '':
            if os.path.exists(pathConcat(u, 'ice.txt')):
                # This is another iCompile project
                usesProjectsList.append(u)
            else:
                usesLibrariesList.append(u)

    quiet = ((configGet(config, 'GLOBAL', 'quiet', True) == 'True') or
             ('--quiet' in args) or ('-q' in args))


def includePaths():
    L = makePathList(configGet(config, 'GLOBAL', 'include'))

    # Add our own include directories
    if isLibrary(state.binaryType):
        for p in ['include', 'include/' + state.projectName]:
            if os.path.exists(p):
                L.append(p + '/')

    # Add any explicit iCompile libraries
    for u in usesProjectsList:
        L.append(pathConcat(u, 'build/install/include/'))

    for p in ['/usr/include', '/usr/local/include', '/usr/X11R6/include', '/usr/local/include/SDL11']:
        if os.path.exists(p):
            L.append(p + '/')

    return L


def libraryPaths():
    L = makePathList(configGet(config, 'GLOBAL', 'library'))

    for p in ['/usr/lib', '/usr/local/lib', '/usr/X11R6/lib']:
        if os.path.exists(p):
            L.append(p + '/')

    # Add any explicit iCompile libraries
    for u in usesProjectsList:
        L.append(pathConcat(u, '/build/install/' + state.platform + '-lib/'))

    return L

def compilerName():
    return configGet(config, 'GLOBAL', 'compiler')

def configCompilerOptions():
    return string.split(configGet(config, state.target, 'compileoptions'), ' ')

def linkerOptions():
    options = string.split(configGet(config, state.target, 'linkoptions'), ' ')
    for option in options:
        if option.strip() == '':
            options.remove(option)
    return options
    

#########################################################################

""" Main program execution.
  Returns the exit code of the build process.
  args     - arguments to iCompile
  progArgs - arguments to pass on to the compiled program
"""
def main(args, progArgs, doGDB, doRun):
    if ("--clean" in args):
        buildClean()
        # Exit early, preventing the cache from being written
        sys.exit(0)
    
    if ("--doc" in args):
        buildDocumentation()
        maybePrintBar()

    if state.binaryType == EXE:
        buildDataFiles()
        maybePrintBar()
        
    buildBinary()

    maybePrintBar()
        
    if isLibrary(state.binaryType):
        buildInclude()
        maybePrintBar()
    
    if doGDB:
        return gdbCompiledProgram(progArgs)

    if doRun:
        return runCompiledProgram(progArgs)

    if not (doGDB or doRun) and (verbosity >= NORMAL):
        if (state.binaryType == EXE):
            print '\nExecutable written to ' + state.binaryDir + state.binaryName
        else:
            print '\nLibrary written to ' + state.binaryDir + state.binaryName
                
    return 0


#################################################################
# Entry point

if __name__ == '__main__':

    # Process global arguments and then invoke the actual build process

    (args, progArgs) = separateArgs(sys.argv[1:])

    # Set the global variables
    i = find(args, '--verbosity')
    if i > -1:
        if i < len(args) - 1:
            try:
                # Clamp verbosity to the legal levels
                verbosity = max(min(string.atoi(args[i + 1]) + QUIET, TRACE), QUIET)
            except ValueError:
                maybeWarn('WARNING: illegal --verbosity argument: ' + args[i + 1])
        else:
            maybeWarn('WARNING: --verbosity used without an argument')

    doGDB   = "--gdb" in args
    doRun   = "--run" in args

    # Root directory
    rootDir                    = os.getcwd() + "/"

    # Project name
    state.projectName                = string.split(rootDir, ('/'))[-2]

    ext = string.lower(extname(state.projectName))
    state.projectName = rawfilename(state.projectName)

    # Binary type    
    if (ext == 'lib') or (ext == 'a'):
        state.binaryType = LIB
    elif (ext == 'dll') or (ext == 'so'):
        state.binaryType = DLL
    elif (ext == 'exe') or (ext == ''):
        state.binaryType = EXE
    else:
        state.binaryType = EXE
        maybeWarn("This project has unknown extension '" + ext +
                  "' and will be compiled as an executable.")

    # Choose target
    if ('--opt' in args) or ('-O' in args):
        if ("--debug" in args):
            colorPrint("Cannot specify '--debug' and '--opt' at " +
                       "the same time.", WARNING_COLOR)
            sys.exit(-1)

        state.target                 = RELEASE
        d                      = ''
    else:
        state.target                 = DEBUG
        d                      = 'd'

    if doGDB and doRun:
        colorPrint("Cannot specify both --gdb and --run options.", WARNING_COLOR)
        sys.exit(-1)

    if (doGDB or doRun) and (state.binaryType != EXE):
        colorPrint("Cannot specify --gdb or --run for a library.", WARNING_COLOR)
        sys.exit(-1)

    # --help and --version are processed immediately
    if ('--version' in args):
        printVersion()
        sys.exit(0)

    if ('--help' in args):
        printHelp()
        sys.exit(0)

    # Find an icompile project file.  If there isn't one, give the
    # user the opportunity to create one or abort.
    checkForProjectFile(args)

    # Load settings from the project file.
    processProjectFile(args)

    # Load cached dependencies for this project
    cacheFilename = tempDir + '.icompile-cache'
    loadCache(cacheFilename)

    configureCompiler()

    setVariables(args)

    ret = main(args, progArgs, doGDB, doRun)

    mkdir(tempDir, verbosity >= VERBOSE)
    saveCache(cacheFilename)
    if (verbosity >= NORMAL) and (configGet(config, 'GLOBAL', 'beep') == 'True'):
        beep()

    sys.exit(ret)
